---
index: 1
icon: creative
title: 복제
category:
  - IT서적
editLink: false
---

## 개요

- 복제란?
  분산된 데이터 베이스 관점에서 복제란 네트워크로 연결된 여러 장비에 동일한 데이터의 복사본을 유지한다는 의미이다.

복제로 인해서 얻을 수 있는 이점은 다음과 같다.

- reduce latency: 지리적으로 사용자와 가깝게 데이터를 유지해 지연시간을 줄인다.
- incerease availability: 시스템 일부에 장애 발생하더라도 지속적으로 동작할 수 있으므로 가용성을 높인다.
- inccrease read througput: 읽기 질의를 제공하는 장비의 수를 확장해 읽기 처리량을 늘린다.

아래 내용들은 데이터 셋이 작아서 각 장비에 전체 데이터 셋의 복사본을 보유할 수 있다는 내용을 가정하고 작성되었다.
데이터 셋이 단일 장비에 보관하기에 클 경우 파티셔닝(샤딩)의 방법을 이용하는데 이 부분에 대해서는 다음장에 공부하기로 한다.
이번장에서 **꼭 이해하고 넘어갈 부분은 리더와 팔로워 방식의 대한 이해와 복제의 3가지 알고리즘과 최종적 일관성에 대한 이해라고 생각한다.**

- 리더와 팔로워

- 3가지 알고리즘

복제의 어려움은 복제되어 여러노드에 보관중인 복제된 데이터의 변경에 있다. 아래 3가지 알고리즘은 노드 간 변경을 복제하기 위한 유명한 알고리즘이다.

- single-leader 단일 리더
- multi-leader 다중리더
- leaderless 리더 없는

거의 모든 분산데이터 베이스가 이 3가지 알고리즘 중 하나를 사용하기에 이 주제의 주된 내용은 3가지 알고리즘이 특성과 장담점을 알아보는것과
복제시에 사용자가 고려해야 할 트레이드오프의 내용들 (ex. 동기 vs 비동기, 잘못된 복제본 처리방법)을 공부할 것이다. 이런 트레이드 오프는 대게 데이터 베이스의 설정옵션으로 주어지므로
사용자가 제대로 알고 선택해야한다.

- 최종적 일관성
  최종적 일관성에 대한 자세한 이해와 그과정에서 발생 할 수 있는 몇가지 문제들
  예를 들어 자신의 쓰기 읽기, 단조읽기 등이 무엇이고 그 문제를 보장하는 내용들을 살펴 본다.

## 리더와 팔로워

다중 복제 서버를 사용하면 모든 복제 서버에 모든 데이터가 있다는 사실을 어떻게 보장 할 수 있을까?
모든 쓰기는 모든 복제 서버에서 처리되어야 하면 그렇지 않으면 복제 서버는 더이상 동일한 데이터를 유지해야한다.
이 문제를 위한 가장 일반적인 해결첵이 리더기반복제이다(reader-based replication)

리더기반 복제란 클라이언트의 읽기 요청은 모든 데이터데이스가 받을 수 있으나 쓰기요청은 리더에서만 받아서 처리하는 방법이다.
리더기반 복제의 쓰기동작은 다음 순서로 진행된다.

1. 복제서버 중 하나를 리더로 지정한다. 다른 복제서버는 팔로워라고 한다.
2. 클라이언트에게 쓰기 요청이 오면 리더에게 보내고, 리더가 먼저 로컬저장소에 새로운 데이터를 저장한다.
3. 리더가 새로운 데이터를 기록할 때마다 데이터 변경을 복제로그나 변경 스트림의 일부로 팔로워에게 전송한다.
4. 팔로워가 리더로부터 로그를 받아 리더의 처리순서와 동일하게 쓰기작업을 적용한다.

클라이언트의 읽기 요청은 리더 또는 임의 팔로워에게 질의 할 수 있다. 그러나 쓰기는 리더에게만 적용된다.
클라이언트에게 팔로워 데이터 베이스는 읽기 전용이다.

- 리더 팔로워 복제는 마스터-슬레이브 라는 용어를 사용하기도 하는데. 보통 '원본' '사본'의 개념으로 사용되는 말이였으나 노예제도를 연상된다는 지적이 많으므로 사용을 자제하는 추세이다. :) 깃헙 브랜치이름이 master -> main으로 바뀐이유와 같은 이유
- 복제서버(replica) : 데이터베이스의 복사본을 저장하는 각 각 노드

### 동기식 대 비동기식 문제

복제 시스템의 중요한 세부 사항은 복제가 동기식으로 발생하는지지 비동이식으로 발생하는지 여부이며, 관계형DB의 경우는 보통 설정 가능한 옵션이다.

여기서 동기 비동기는 의미는 클라이언트가 리더에게 쓰기 요청을 보낸 후 리더가 클라이언트에게 작업의 결과를 응답하는 시점과 관련이 있다.
리더는 쓰기요청을 받으면 팔로워에게 변경을 알린다.
동기식 복제는 리더가 팔로워가 쓰기를 수신했는지 확인 한 후 클라이언트에게 응답하는 방식이고
비동기식 복제는 팔로원의 OK메세지를 기다리지 않고 바로 클라이언트에게 응답하는 방식이다.

동기식 복제의 장점은 팔로워와 리더가 일관성있게 최신데이터 복사본을 가지는 것을 보장하는 것이다. 그러나 단점은 동기 팔로워가 응답하지 않는다면 쓰기요청이 처리되지 않는다. 동기 복제서버가 다시 정상화 될때까지 기다려야 한다. 그렇기에 모든 팔로워가 동기식인 상황은 비현실적이며 보통 데이터베이스에서 동기식 복제를 사용할 떄는 팔로워 하나는 동기식으로하고 그 밖에는 비동기식으로 하는 것을 의미한다.
이것은 적어도 두노드에 데이터 최신복사본이 있다는 것을 보장하며 이런 설정을 반동기식 이라고 한다.

동기식의 장점을 설명했지만 보통 리더 기반 복제는 완전히 비동기식으로 구성한다. 이 경우 리더가 잘못되고 복구 할 수 없을 때 아직 팔로워에 복제되지 않은 모든 쓰기는 유실된다.
그러나 완전 비동기식 설정은 모든 팔로워가 잘못되더라도 리더가 쓰기 처리를 계속 할 수 있다는 장점이 있다.

완전 비동기식복제는 내구성을 약화시키기 때문에 나쁜트레이드오프라 생각할수 있지만 많은 팔로워가 있거나 지리적으로 분산되어 있다면 비동기식 복제를 널리 사용한다.
이것은 복제지연문제와 관련되어 있는데 뒷 부분의 \_\_ 에서 자세히 설명한다.

### 새로운 팔로워 설정

복제 서버 수를 늘리거나 장애 노드의 대체를 위해 새로운 팔로워를 설정해야 할 때가 있다.
새로운 팔로워가 리더의 데이터 복제본을 정확히 가지고 있는지는 어떻게 보장 할 수 있을까?

데이터는 항상 유동적이기 때문에 단순한 노드에서 노드로의 파일 복사는 결과가 유효하지 않을 수 있다.
데이터 베이스를 잠그고(lock을 걸고) 노드를 복사하면 쉽게 해결 할 수 있을지도 모르나. 고가용성 목표에는 부합하지 않는다.

중단시간 없이 새로운 팔로워 설정하는 개념적인 방법은 다음과 같다.

1. 리더의 데이터베이스의 스냅숏을 일정시점에 가져온다.
2. 스냅숏을 새로운 팔로워 노드에 복사한다.
3. 팔로워는 리더에 연결해 스냅숏 이후 발생한 모든 데이터 베이스 변경을 요청한다.
4. 팔로워가 스냅숏 이후의 데이터 미처리분(backlog)를 모두 처리했을 때 따라잡았다고 말하고, 이후부터 리더에게 발생하는 데이터 변화를 이어서 처리 할 수 있다.

물론 실제과정은 데이터베이스마다 크게 다르다.

### 노드 중단 처리

시스템의 모든 노드는 장애로 혹은 계획된 유지보수로 인해 중단 될 수 있다.
개별 노드의 장애에도 전체 시스템이 정상작동하고 노드 중단의 영향을 최소화하는
리더기반복제에서의 고가용성은 어떻게 달성할 수 있을까?

- 팔로워 장애 : 따라잡기 복구
  각 팔로워는 리더로 부터 수신한 데이터 변경로그를 로컬디스크에 보관한다.
  팔로워 장애 복구는 간단하다. 자신에게 결함이 발생하기 전에 처리한 마지막 트랜잭션을 알아낸 후 팔로워는 리더에게 연결이 끊어졌던 동안 발생한 데이터 변경을 모두 요청한다.
  해당 변경사항이 다 적용되서 리더를 따라잡은 후에 이전과 같이 데이터 변경 스트림을 계속 받는다.
- 리더 장애 : 장애복구
  리더의 장애를 처리하는 일은 까다롭다.

1. 팔로워 중 하나를 새로운 리더로 승격해야 하고
2. 클라이언트는 새로운 리더에게 쓰기 요청을 전송하기 위해 재설정이 필요하면
3. 다른 팔로워는 새로운 리더로부터 데이터 변경을 소비해야한다.
   이 과정을 장애복구(failover)라 한다.

장애 복구는 수동 혹은 자동으로 진행하는데 자동 장애복구는 다음과 같은 단계를 거친다.

1. 리더가 장애인지 판단한다 : 장애의 원인을 파악할 방법 없기 때문에 대부분은 타임아웃을 사용한다.

- 판단은 하트비트? 사용 노드들이 서로 메시지 주고 받으며 일정시간동안 노드 응답없으면 죽은것으로 간주

2. 새로운 리더를 선택한다: 가장적합한 후보는 보통 이전 리더의 최신데이터 변경사항을 가진 복제 서버 모든노드가 새노드의 동의를 구하는 합의 문제는 이후 일관성합의에서 자세히 다룬다.
3. 새로운 리더 사용을 위해 시스템을 재설정한다 : 클라이언트가 쓰기 요청 새로운 리더에게 보내야 하며, 시스템이 이전 리더가 팔로워되고 새로운리더 인식하겠금 설정

그러나 자동 장애복구 과정은 문제점이 많다.
비동기 복제사용시 이전리더가 가지고 있던 쓰기의 일부가 수신되지못한경우 이전리더가 되면 이 데이터는? 폐기하게 되면 내구성에대한 기대를 저버림.
리더가 죽었다고 판단하는 적절한 타임아웃은?
특정 결함 시나리오에서 두노드가 자신이 리더라고 믿는 상황

이런이유로 일부 운영핌은 자동장애복구를 지원해도 수동으로 장애복구를 수행하는 방식을 선호한다.

### 복제 로그 구현

\*아직 이해가 잘 안감. 추후에 작성

## 복제지연과 최종적일관성

## 단일리더 복제

## 다중리더 복제

## 리더없는 복제
