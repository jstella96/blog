---
index: 8
icon: creative
title: 클래스
category:
  - JavaScript
editLink: false
---

## CLASS
CLASS : 공통적인 속성을 모다 한데 묶은 덩어리 또는 명세 / 인스턴스들의 공통속성을 모은 추상적인 개념 / 음식,과일
인스턴스 : 해당 클래스의 속성을 지닌 구체적인 객체들 /배,사과 바나나

프로그래밍은 상위 클래스가 먼저 정의 되어야만  하위 클래스와 인스턴스를 정의 할 수 있다.

음식(superclass- 상의클래스) 과일 (subclass)


배열 + prototype = > class
배열객체 = > 인스턴스


프로토 타입 프로퍼티 내부에 할당되지 않고 Array생성자 함수 객체에 직접 할당되어 있는 함수들을
스태틱메서드, 스태틱 프로퍼티 라고 칭한다. 이들은 Array생성자 함수를 new 연산자 없이 함수(객체)로서 호출할때만 의미가 있는 값들이다.
보통 인스턴스의 개별동작이 아닌 소속여부 확인, 소속 부여등 공동체적인 판단이 필요한 경우에 활용,
 프로토 타입내부에 정의된 메서드들을 일컬어 프로토타입메서드라고 하는데 앞에 프로토 타입 생략해서 말하는 경우가 많다. 

 스태틱멤버은 인스턴스가 직접 접근 불가. 

```js
function Person(name, age){
  this._name = name;
  this._age = age;
}
//static method
Person.getInformations  = function(instance){
  return{
    name: instance_name;
    age: instance._age
  }
}

//(prototype)method
Person.prototype.getAge = function(){
  return this._age;
}
//(prototype)method
Person.prototype.getName = function(){
  return this.age;
}

var roy = new Person('로이',30);

console.log(roy.getName()) // ok
console.log(roy.getInformations())// error
console.log(Person.getInformations(roy))// error

```

정리 : 
클래스는 어떤 공통된 속성이나 기능을 정의한 추상적인 개념이고 이 클래스에 속한 객체를 인스턴스라고 합니다. 
클래스에는 인스턴스에서는 직접 접근할 수 없는, 클래스 자체에서만 접근 가능한 스태틱 멤버와 인스턴스에서 직접 활용할 수 있는 프로토타입 메서드가 있다.


## CLASS INHERITANCE 클래스 상속
```JS
function Person(name, age){
  this._name = name || '이름없음';
  this._age = age || '나이모름';
}


Person.prototype.getAge = function(){
  return this._age;
}

Person.prototype.getName = function(){
  return this.age;
}
```

```JS
function Person(name, age,position){
  this._name = name || '이름없음';
  this._age = age || '나이모름';
  this._position || '직책모름';
}


Person.prototype.getAge = function(){
  return this._age;
}

Person.prototype.getName = function(){
  return this.age;
}

Person.prototype.getPosition = function(){
  return this._position;
}
```
위 클래스들은 getName, getAge 가 겹친다.
person클래스 하위에 employee 가 있는 구조로 만들어 주면 해결이 될꺼같다.
 
 겹치는 메서드는 상의인 Person에만 놔두고 
 Employee에는 겹치지 않는 메서드만 남긴다.
 그렇게 만든 Emply.. 인스턴스트는 프로토타입 체인을 타고 Empl.. 메서드와 Person의 메서드를 사용할 ㅅ ㅜ있다. 

 만드는 법은? 
 삼각형 꼭지점 연결
 Employee.prototype = new Person();
 //원래 있던 프로토 타입객체와 같은 기능 수행하도록
 Employee.prototype.constructor = Employee 
 이 두작업을 해주면 서로 다른 두개의 클래스가 superclass subclass 관계가지게 된다. 

 ```JS
function Person(name, age){
  this._name = name || '이름없음';
  this._age = age || '나이모름';
}


Person.prototype.getAge = function(){
  return this._age;
}

Person.prototype.getName = function(){
  return this.age;
}

function Person(name, age,position){
  this._name = name || '이름없음';
  this._age = age || '나이모름';
  this._position || '직책모름';
}

 Employee.prototype = new Person();
 Employee.prototype.constructor = Employee 
 //위에서 덮어 씌우기 때문에 아래에다가
 Employee.prototype.getPosition = function(){
  return this._position;
}

var roy =new Employee('로이',30,'ceo')
console.dir(roy)
```
콘송창 예시
prototype 체이닝 상에는 프로퍼티가 아닌 메소드들만 존재 하게끔 하는 것이 추상적인 클래스라고 하는 저으이에 부합하다. 

Bridge를 이용해본다

 ```JS
function Person(name, age){
  this._name = name || '이름없음';
  this._age = age || '나이모름';
}


Person.prototype.getAge = function(){
  return this._age;
}

Person.prototype.getName = function(){
  return this.age;
}

function Person(name, age,position){
  this._name = name || '이름없음';
  this._age = age || '나이모름';
  this._position || '직책모름';
}

function Bridge() {}; // 아무런 프로퍼티도 생성하지 않는 비여있는 생성자 함수
 Bridge.prototype  = Person.prototype;
  Employee.prototype = new Bridge;
 Employee.prototype.constructor = Employee 
 //위에서 덮어 씌우기 때문에 아래에다가
 Employee.prototype.getPosition = function(){
  return this._position;
}
var roy =new Employee('로이',30,'ceo')
console.dir(roy) //이쁜결과
```
브릿지라는 매게체를 이용해서 PErson의 인스턴스와의 연결관계를 끊음으로서
프로토타입 체인상에 불필요한 프로퍼티가 등장하지 않게끔 하는데 성공
이기능은 es5에서 상속을 구현하는데 자주 등상하기도 하거니와
더글라스 포드? 
함수화 코드 확인  
```

```
한번만 구현!! 
변수 super클래스 변수 할당 

``` // 최종 정리 .
```

es6에서는 구지 이런과정없이도 .extends 