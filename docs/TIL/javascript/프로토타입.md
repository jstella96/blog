---
index: 2
icon: creative
title: 프로토타입
category:
  - JavaScript
editLink: false
---

## prototaype

!()[]
생성자 함수가 있을 때 new 연산자로 인스턴스를 만들면 그 인스턴스에는 Constructor의 prototype를 해당 인스턴스의 [[Prototype]]이 바라보게 된다. 
즉 Constructo.prototype 과 instance[[Prototype]]가 같은 객체를 바라보게 된다.
근데 [[Prototype]]는 접근가능한 것이 아니라 정보를 보여주기만 할뿐이다.

예를 들어 Array 생성자 함수로 배열을 생성하면 Array 생성자 함수를 출려가면 prototype에 배열메소드가 다들어가 있고 이게 생성한 배열에 [[prototype]]에 들어가 있다. 


실습해보고 사진 

Array.prototype.constructor에는 다시 Array 즉 생성사 함수 자신을 가리킨다. 
배열.constructor 역시 똑같이 배열릐 생성자 함수를 가리킨다.


배열.constructor 은 배열.[[Prototype]].constructor(실제 이렇게 접근x)와 동일하게 인식
즉 == Array.prototype.constructor와 동ㅇㅣㄹ하다. 
이들은 Array생성자 함수를 가리키게 된다.

정리 배열은 Array 생성자 함수와 그 프로토 타입으로 이루어져 있는데 프로토 타입에는 배열과 관련된 메서드들이 모두 들어있다.

그러면 숫자 리터럴은 어떨까? 숫자 리터털 자체는 객체가 아니므로 [[Prototype]] 있을 수 없는데 사용자가 객체로 쓰려고 하면 즉 메소드를 쓰려고 하면 자바스크립트가 임시로 숫자 리터럴에 해달하는 Number생성자 함수 인스턴스를 만들어서 그 프로토 타입에 있는 메서드를 적용해서 원하는 결과를 얻게 한 다음에 다시 인스턴스를 제거하는 식으로 동작을 한다.

문자열도 마찬가지로 어떤 메서드를 호출하는 순간에 임시로 문자열의 인스턴스를 만들어서 그 메서드를 실행하고 그 결과를 얻음과 동시에 인스턴스를 다시 폐기한다. 기본형 타입의 데이터들은 모두 이같은 방식에 의해 메서드를 호출할 수 있다
한편 참조형 데이터들은 처음부터 인스턴스이기 때문에 위 같은 복잡한 과정을 거치지는 않는다.
어쨌든 결국 숫자형이든, 문자형이든, 배열이든, 함수든 할 것 없이 모두 메서드에 접근하고 자 할때는 
모두 아래와 같은 구조가 된다. 
생성자 -> 생성자.prototype{method1, method2,method4}
 l
data

데이터 자신에게는 메서드들이 없지만 생성자들의 prototype에 있는것을 [[pro]]라는 연결통로에 의해서 자싲의 것처럼 쓸 수 있다. 
null과 undefined를 제외한 모든 데이터 타입은 이와 같은 생성자 함수가 존재한다. 각 생성자 함수의 프로토타입에는 각 데이터 타입에만 해당하는 전용메서드들이 정의가 되어있다.

여기서 주의 [[Prototype]]는 콘솔에 표시가 되는 내용일 뿐이고 실제로 이 프로퍼티를 이용해서 프로토타입에 직접 접근할 수 는 없다.

그렇다면 실제로 인스턴스로 부터 접근하려면 어떻게 하느냐?
```
instance.__proto__  => 호환성차원에서 문사화 해준 것 
Object.getPrototypeOf(instance) = > 공식적인 방법
```
위같은 방법 2개가 있다
Object.getPrototypeOf(instance) 를 상ㅅㅇ해라
## [[Prototype]]
## constructor