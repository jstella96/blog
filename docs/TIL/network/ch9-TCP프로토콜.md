---
index: 2
icon: creative
title: TCP프로토콜
category:
  - Network
tag:
  - 네트워크
editLink: false
---

:::tip

- TCP가 하는 일
- TCP 프로토콜의 구조
- TCP 플래그의 종류
- 각 플래그의 기능
- 연결 수립 과정
- 3WayHandshake 데이터 송수신 과정
- TCP 연결 상태의 변화 3Way Handshaking과 함께보기
- TCP 3Way Handshake 과정 계산해보기
- TCP 프로토콜 분석하기
  :::

## TCP 프로토콜

- TCP가 하는 일
  연결을 지향하기 때문에 UDP보다는 안정적이다. 일반적으로 통신을 한다고 했을 때
  TCP/IPv4/이더넷 이렇게 사용한다.

전송 제어 프로토콜(Transmission Control Protocol, TCP)은 인터넷에
연결된 컴퓨터에서 실행되는 프로그램 간에 통신을
안정적으로, 순서대로, 에러없이 교환할 수 있게 한다.
TCP의 안정성을 필요로 하지 않는 애플리케이션의 경우 일반적으로
TCP 대신 비접속형 사용자 데이터그램 프로토콜(User Datagram
Protocol)을 사용한다.
TCP는 UDP보다 안전하지만 느리다.(이론상 느릴 수 있다지 그래도 빠르다.)

- TCP 프로토콜의 구조
  ![tcp 구조](./img8-udp프로토콜-패킷캡처-ㅆㄹ쎼.png)
  가장 일반적 길이 20Byte인데 60Byte 까지 늘어 날수 있다.

<구조>
출발지 포트 2
목적지 포트 2
시퀀스 넘버 4
ackno.. 4
오프셋 : 오프셋이라기보다 헤더길이 /4 해준다.
리절브드 : 예약된 필드. 사용하지 않음
Flag
윈도우: 데이터 얼마만큼 더 보내.~ 내 사용공간이 얼마만큼 남아있는 지알려주는 것. 내 남아있는 TCP버퍼 공간 알려주는것
체크썸 : 체크썸
UrgentPointer
TCP 옵션 : 4 바이트 씩 붙기 해당 옵션때문에 60Byte 까지 늘어 날수 있다.

## TCP 플래그

![tcp 구조-flag](./img8-udp프로토콜-패킷캡처-ㅆㄹ쎼.png)
박스 친 부분 주의.
TCP가 여러가지 형태로
내가 연결하려고 물어보는 건지, 대답하는건지 연결 종료 하려는 건지 연결 초기화, 데이터 보내려하는지 급한건지..  
 tcp주된기능이 이 플래그로 나뉘어 진다.
U: 어전트 플래그 긴급비트, 내가 보내는 데이터에 우선순위높은 데이터 포함되어 있다.
Urgent Pointer 와 세트 어디 부터가 긴급데이터인지 알려줌
A : 애크 플래그, 승인 비트, 물어본거에 대한 응답을 해줄때, 어 데이터 보내도 됨 승인, 어 나랑 연결해도 되 이런식으로 승인 해주는 플래그
P: push 밀어 넣기, tcp 버퍼가 일정한() 내가 받을 수 있는 공간) 일정 크기 만큼 차야지 추가 전송가능한데 그거 상관 없이 밀어 넣겠다.
R: 초기화 비트 상대방하고 연결이 되어 있는 상태에서 추가적으로 데이터 주고 받으려고 하는데 문제가 발생 해서 우리 사이 관계를 초기화 하자. 리셋 하자
S: 싱크 비트. 동기화 비트 상대방하고 연결을 시작할때 무조건 사용하는 플래그, 얘가 처음 보내지고 난 다음부터 이 둘사이의 연결이 동기화기작한다. 보내도되? 응 보내도되 잘받았어 ? 응 잘받았어
F: 삔? 종료비트 마지막에 데이터 다 주고 받은 휴에 연결울 끊을때 사용하는 플래그다. 실제
ARSF중요  
![tcp 구조-flag](./img/09.tcp-플래그.png)

- 지금은 set 플래그만 세팅 꼭 하나만 쓸 수 있는건 아님 여러개 쓸수있음

Urgent : 긴급 bit
Acknowledgment : 승인 bit
Push : 밀어넣기 bit
Syn : 동기화 bit
Fin : 종료 bit
Reset : 초기화

## TCP를 이용한 통신과정

- 둘 사이의 연결 수립과정
  TCP를 이용한 데이터 통신을 할 때 프로세스와 프로세스를 연결하기 위해
  가장 먼저 수행되는 과정

1. 클라이언트가 서버에게 요청 패킷을 보내고
2. 서버가 클라이언트의 요청을 받아들이는 패킷을 보내고
3. 클라이언트는 이를 최종적으로 수락하는 패킷을 보낸다.
   위의 3개의 과정을 3Way Handshake라고 부른다.

우리가 사용하는 대부분의 통신에 사용 웹, 파일전송, 게임 등..
통신하려고 할때 가장먼저 수행되는 과정
이 과정 지나고난 다음에야 데이터 전송

이과정이 총 3가지 상태.

1. 클라이언트가 서버에게 먼저 연결해도 되냐고 요청패킷을 보낸다.
   (서버가 먼저 보내는 경우 x)
2. 해당요청을 받은 서버가 연결 요청 수락+ 서버도 클라이언트 한테 연결 요청을 보낸다.
3. 클라이언트가 최종적으로 수락.

클라이언트 크롬같은 프로그램
서버 네이버 다음등이 사용하는 아파치, nginx

첫번째 연결에는 특별한 페이로드 없음. 싱크 플래그 간다.
출발지 포트: 사용자 포트중 아무거나
목적지 포트: 80번 웹이니까.

목적지에서 디캡슐래이션해서 플래그 보고 나한테 요청하는구나 알아차리고
다시 보낸다.
플래그 싱크랑 애크가 같이 세팅해서 간다.

마지막 연결 수락

![tcp 구조-flag](./img/09.tcp-플래그-도식도.png)
결론 : 처음 네트워크 통신할때 3 핸드 쉐이크한다. 각 플래그 셋팅해서 간다.

+보안까지 하려면 S : A: 값 계산 할 줄 알아야한다.
세션하이제킹, DOS공격 저 값으로 할 수 있다.
![시쿼스-애크번호](./img/09.tcp-플래그-도식도.png)

1.  맨 처음 클라이언트가 시퀀스 번호 100 애크 번호 0으로 셋팅했다.(이건 클라이언트 마음 보통 시퀀스에 랜덤 애크 0번 셋팅되서 간다 )
    이랬을 때 받는 쪽에서 이 값과 동기화 시킨다.
2.  애크 번호는 답장을 줄때 받은 시퀀스 번호 +1 을 한다.
    시퀀스 번호는 랜덤하게 생성해서 준다.
3.  애크번호는 받은 시퀀스 번호 +1
    그 다음 시퀀스 번호는 받은 애크번호를 준다.

이제 연결이 수립됐다.
이 다음은 클라이언트가 요청을 보낸다.
이랬을때 클라이언트가 아닌 누군가가 저 값을 가지고 만약 누군가가 동기화된 값을 계산해가지고
서버한테 보내면???
그 누군가가 서버랑 통신하고 있다.

이게 세션 하이제킹 ..
근데 이게 이미 로그인 된 후 연결 뺏어갔다고 하면 문제이다.

해커는 저 값을 계산하는 거다.

3웨이 핸드 쉐이크 연결수립!! TCP를 이용한 통신 시작할때 무조건 이루어지는 과정

- 데이터 송수신과정

* 연결 수립 다음에 하는 통신. S 번호 A 그래로 이어간다
  마지막에 클라이언트 -> 서버로 보내면서 연결 끝났으니
  가지고 있는 값 같다. 또 클라이언트 -> 서버
  이후 규칙. +1 이아니라 데이터 크기가 들어간다.

TCP를 이용한 데이터 통신을 할 때 단순히 TCP 패킷만을 캡슐화해서
통신하는 것이 아닌 페이로드를 포함한 패킷을 주고 받을 때의 일정한 규칙

1. 보낸 쪽에서 또 보낼 때는 SEQ번호와 ACK번호가 그대로다.
2. 받는 쪽에서 SEQ번호는 받은 ACK번호가 된다.
3. 받는 쪽에서 ACK번호는 받은 SEQ번호 + 데이터의 크기

![시쿼스-애크번호](./img/09.tcp-플래그-도식도.png)

1. 데이터가 데이터를 보낸다.
   플래그는 푸쉬, 애크

2. 받는 쪽에서 답장 요청받은 데이터 보내면서
   A : 201 - > 클라이언트가 보낸 데이터가 100이라
   S : 는 그대로

3. 받은 클라이언트 잘받았다고 대답

S: 받은 애크번호 그래돌
A L 2501 받은 시퀀스 번호에 받은 데이터 더해주는 것.

그 후에 연결 끝는다.
연결 끊는건 TCP 사용하는 프로그램 만드는 곳 마다 조금씩다르다. 3 핸드 쉐이크 처럼 단순히 패킷만 보낸다.

## TCP 상태전이도

TCP의 상태변화

중요한거 Listen 상태 : 포트번호를 열어놓고 있는 상태, 서버가 포트번호 사용하고 있는.
클라이언트의 요청을 계속 듣고 있는 상태
ESTABLISHED : 연결이 서로 수립되어 있는 상태 3핸드쉐이크 끝나면 수힙된다.
CLOSED
![상태](./img/09.tcp-상태.png)
위처럼 tcp 통신 시작할때 클라이언트는 SYN_SENT 상태가 되고 싱크 요청받은 서버는
Listening상태에서 SYN_RECEIVED상태가 된다.
핸드쉐이크 과정끝나면 클라이언트와 서버가 ESTABLISHED 상태가 되고, 통신가능해진다.

## 실습

wire sg tcp 캡처후 하나 클릭 우클릭 -> follow -> tcp stream 클릭하면
![](/tcp - 실습)
point 1. 처음 핸드쉐이크 과정 seq, ack
point 2. 4 번째 통신 다시 클라이언트가 서버한테
point 3. 5번째 통신 ack 에는 seq + data (직전 tcp 통신이 보낸 tcp의 페이로드)
