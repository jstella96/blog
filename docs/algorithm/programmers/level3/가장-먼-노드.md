---
index: 1
icon: creative
title: 가장 먼 노드
category:
  - algorithm
tag:
  - DFS
---

[문제 링크](https://programmers.co.kr/learn/courses/30/lessons/49189)

## 문제 설명


## 입출력 예시



## 문제 풀이



## 풀이코드 Java

## 풀이 코드 JavaScript
bfs 풀이! 
```js 
//시간 초과가 나오는 이유 처음 노드 방문할 때 모든 노드를 가버리는 문제가 있다!
function solution(n, edge) {
    const distance = new Array(n+1).fill(-1); //[무시,1번노드까지,2번노드까지..];
    const graph = new Map();
    for(const [source, destination]  of edge){ //자바스크립트는 Array로 만들어도된다.
        if(!graph.has(source)) graph.set(source, new Array());
        if(!graph.has(destination)) graph.set(destination, new Array());
        graph.get(source).push(destination);
        graph.get(destination).push(source);
    }

    bfs(graph, 1, distance)
    let maxDistance = Math.max(...distance);
    return distance.filter(x => x === maxDistance).length;
}

function bfs(graph, source, distance){
    const queue = [];
    queue.push(source);
    distance[source] = 0;
    while(queue.length != 0) { // 큐가 빌 때까지 반복
        const currentNode = queue.shift();
        const nextNodeList = graph.get(currentNode);
        for(let nextNode of nextNodeList){
            if (distance[nextNode] == -1) { //방문안했으면 
                distance[nextNode] = distance[currentNode] + 1; //이 부분 주의! => 고민하다 다른 풀이보고 힌트를 얻었다 
                queue.push(nextNode);
            }
        }
    }
}

```
*  런타임 에러! BFS를 DFS로 풀면 visited를 써도 문제가 있다. 풀이에따른 풀이 방법을 잘 선택하자
```js
//시간 초과가 나오는 이유 처음 노드 방문할 때 모든 노드를 가버리는 문제가 있다!
function solution(n, edge) {
    const distance = new Array(n+1).fill(99999); //[무시,1번노드까지,2번노드까지..]
    distance[0] = 0;
    const graph = new Map();
    for(const [src, dest]  of edge){ //자바스크립트는 Array로 만들어도된다.
        if(!graph.has(src)) graph.set(src, new Array());
        if(!graph.has(dest)) graph.set(dest, new Array());
        graph.get(src).push(dest);
        graph.get(dest).push(src);
    }
    recursive(1, distance, graph, 0)
    let maxDistance = Math.max(...distance);
    return distance.filter(x => x === maxDistance).length;
}
function recursive(source, distance, graph, count) {
    if(distance[source] <= count) return; // visited의 역할
    distance[source] = count;
    const destinations = graph.get(source);
    for(let destination of destinations){
        recursive(destination, distance, graph, count+1);
    }
}
```