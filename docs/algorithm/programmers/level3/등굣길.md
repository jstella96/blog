---
index: 1
icon: creative
title: 등굣길
category:
  - Algorithm
tag:
  - DFS
---

[문제 링크](https://programmers.co.kr/learn/courses/30/lessons/42898)

## 문제 설명


## 입출력 예시



## 문제 풀이



## 풀이코드 JavaScript

```js


let countMemo = {
    'min' : 999,
    'count' : 0 
}
function solution(m,n,puddles) {
    // 단순 최단 경로 문제가 한번 더 꼬인 것 뿐
    //1. 2중배열을 만들고 웅덩이가 있으면 -999 표시를 해준다. 나머지는 0; 추후 방문했으면 1로 바꿈.
    let gride = new Array(n).fill(0).map(() => new Array(m).fill(0));
    for(puddle of puddles){
        gride[puddle[1]][puddle[0]] = -999;
    }
    dfs(0,0,gride,0,m,n);
    return countMemo.count
}
function dfs(x, y, gride, count, xMax, yMax){
 
    if( x > xMax-1 || y > yMax-1){
        return;
    }
    if( gride[y][x] == -999 || gride[y][x] == 1 ){ return;}
    if(x == xMax-1 && y == yMax-1){
        if(countMemo.min == count){
            countMemo.count++;
        }else if(countMemo.min > count){
            countMemo.min = count;
            countMemo.count = 1;
        }
    }
    gride[y][x] = 1;
    dfs(x+1, y, gride, count+1, xMax, yMax);
    dfs(x, y+1, gride, count+1, xMax, yMax);
    gride[y][x] = 0;
}

console.log(solution(4,3,[[2, 2]]));

```
