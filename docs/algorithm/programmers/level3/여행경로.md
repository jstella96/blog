---
index: 1
icon: creative
title: 여행경로
category:
  - Algorithm
tag:
  - DFS
---

[문제 링크](https://programmers.co.kr/learn/courses/30/lessons/43163)

## 문제 설명

문제 설명 
주어진 항공권을 모두 이용한 공항경로를 구한다. 

문제 조건
항상 "ICN" 공항에서 출발한다
tickets의 각 행 [a, b]는 a 공항에서 b 공항으로 가는 항공권이 있다는 의미입니다.
주어진 항공권은 모두 사용해야 합니다.
만일 가능한 경로가 2개 이상일 경우 알파벳 순서가 앞서는 경로를 return 합니다.
모든 도시를 방문할 수 없는 경우는 주어지지 않습니다
정렬을 할 것인가..  마지막에 점검을 할것인가...


## 입출력 예시



## 문제 풀이



## 풀이코드 Java
* 정확도는 100%인듯 하나 시간초과가 나온다.

```java

import java.util.*;

class Solution {
  String[] answer;
int num =0;
  public String[] solution(String[][] tickets) {
    int len = tickets.length;
    answer = new String[len+1]; 
    HashMap<String, Queue<String>> map = new HashMap<String, Queue<String>>();
    // 1. map 에 각 항공권이 갈 수 있는 곳 넣음.
    for (String[] airport : tickets) {
      if (!map.containsKey(airport[0])) {
        Queue<String> list = new LinkedList<String>();
        map.put(airport[0], list);
      }
      map.get(airport[0]).add(airport[1]);
    }
    // 2. 이건 최소 거리가 아니다 하나하나 탐색후 알파벳순서가 앞인 경로를 찾는것. 만약 정렬이 되었다면.. 바로 리턴 할 수 있다는 장점이 있다
    String[] airports = new String[len+1];
    dfs("ICN", 1, len+1, map, airports);
    return answer;
  }

  public void dfs(String start, int idx, int len, HashMap<String, Queue<String>> map, String[] airports){
        airports[idx-1] = start;
        if(idx == len){
          check(airports);
          return;
        }
        Queue<String> list = map.get(start);
        //이때 sorting을 하나 안하나.. 
        int size = list.size();
        for(int i=0; i< size; i++){
            String end = list.poll();
            dfs(end, idx+1, len, map, airports);
            list.add(end);
        } 
    }
    
    public void check(String[] airports){
        if(answer[0]==null){
            answer = airports.clone();
            return;
        } 
        for(int i =0 ; i<airports.length; i++){
            System.out.print(airports[i]);
            System.out.println(answer[i]);
            System.out.print(answer[i].compareTo(airports[i]));
            if(answer[i].compareTo(airports[i])  > 0){
              
              answer = airports.clone();
              return;    
            }else if(answer[i].compareTo(airports[i]) < 0)return;
        }
    }
}
```

## 풀이 코드 JavaScript
*  런타임 에러.. 
```js
let answer; 
function solution(tickets) {
    answer = [];
    const map = new Map();
    let idx = 0;
    for(let ticket of tickets){
        if(!map.has(ticket[0])) map.set(ticket[0],new Array())
        map.get(ticket[0]).push(idx);
        idx++;
    }
    const visited = new Array(tickets.length).fill(0);
    recursive("ICN", visited, map, tickets,["ICN"]);
    return answer;
}
function recursive(start, visited, map, tickets, answerArray){
    if(tickets.length+1 == answerArray.length) { 
        if(answer.length != 0){
            answerArray = answer.toString() > answerArray.toString() ? answerArray: answer;
        }
        answer = [...answerArray];
        return;
    }
    const endIdxList =  map.get(start);
    for(let endIdx of endIdxList){
        if(visited[endIdx] == 1)continue;
        visited[endIdx] = 1;
        answerArray.push(tickets[endIdx][1])
        recursive(tickets[endIdx][1],visited, map, tickets, answerArray )
        answerArray.pop();
        visited[endIdx] = 0;
    }
}

//tickets : [["ICN", "JFK"], ["HND", "IAD"], ["JFK", "HND"]]	
//return  : ["ICN", "JFK", "HND", "IAD"]
```