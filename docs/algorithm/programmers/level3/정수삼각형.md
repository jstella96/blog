---
index: 1
icon: creative
title: 정수 삼각형
category:
  - algorithm
tag:
  - DP
---

[문제 링크](https://programmers.co.kr/learn/courses/30/lessons/43105)

## 문제 설명

삼각형의 꼭대기에서 바닥까지 이어지는 경로 중, 거쳐간 숫자의 합이 가장 큰 경우를 찾아보려고 합니다. 아래 칸으로 이동할 때는 대각선 방향으로 한 칸 오른쪽 또는 왼쪽으로만 이동 가능합니다. 예를 들어 3에서는 그 아래칸의 8 또는 1로만 이동이 가능합니다.

삼각형의 정보가 담긴 배열 triangle이 매개변수로 주어질 때, 거쳐간 숫자의 최댓값을 return 하도록 solution 함수를 완성하세요.

## 입출력 예시

```
Input: [[7], [3, 8], [8, 1, 0], [2, 7, 4, 4], [4, 5, 2, 6, 5]]
Output: 30
```

## 문제 풀이

dfs를 이용해서 모든 경우를 구한다.  
이문제는 메모라이즈를 안하면 시간초과가 발생한다.

## 풀이 코드

```java
class Solution {
   Integer[][] memo;
   public int solution(int[][] triangle) {
	  	memo = new Integer[triangle.length-1][triangle.length-1];
      int max = dfs(triangle, 0, 0);
      return max;
    }
    int dfs(int[][] triangle, int i, int h){
      if(h == triangle.length-1) return triangle[h][i];
      if(memo[h][i] != null) return memo[h][i];
      int a1 = triangle[h][i] + dfs(triangle, i, h+1);
      int a2 = triangle[h][i] +  dfs(triangle, i+1, h+1);
      int max = memo[h][i] = Math.max(a1,a2);
      return max;
    }
}
```

- 시간초과 코드

```java
class Solution {
    int max = 0;
    public int solution(int[][] triangle) {
        dfs(triangle[0][0], triangle, 0,1);
        return max;
    }
    void dfs(int sum,int[][] nums, int i, int h){
        if(h == nums.length){
             max = Math.max(max, sum) ;
          return;
        }
		      dfs(sum+nums[h][i], nums, i, h+1);
          dfs(sum+nums[h][i+1], nums, i+1, h+1);
     }
}
```
