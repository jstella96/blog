---
order: 1
icon: creative
title: 신뢰성, 확장성, 유지보수성
category: IT서적
tag:
  - chapter 1
---

> Reliable, Scalable, and Maintainable Applications

## 데이터 중심 애플리케이션

오늘날 많은 애플리케이션은 **계산 중심(compute-intensive)** 과는 다르게 **데이터 중심(data-intensive)** 적이다.
이러한 애플리케이션에서 성능을 제한 하는 요소는 CPU보다는 데이터의 양, 데이터의 복잡도, 데이터의 변화 속도다.
일반적으로 이런 데이터 중심 애플리케이션은 공통으로 아래와 같은 요소들을 필요로 한다.

```
- 데이터를 저장 (DB)
- 읽기 속도 향상을 위해 값이 비싼 수행 결과를 기억 (캐시)
- 키워드로 데이터 검색하거나 필터링 하게 제공 (검색색인-search index)
- 비동기 처리를 위해서 다른 프로세스로 메세지 전송(스트림 처리-stream processing)
- 주기적으로 대량의 누적된 데이터를 분석(일괄/배치 처리-batch processing)
```

오늘날의 데이터 시스템은 성공적으로 추상화 되어있어서 위와 같은내용이 당연하게 들리기도 한다. 그러나 현실은 이론 만큼 간단하지 않다. 데이터 베이스 시스템 또한 저마다의 특성을 가지고 있기 때문에 애플리케이션을 만들 때 어떤 도구와 어떤 접근 방식이 수행 중인 작업에 가장 적합한지 생각해야 한다.이 후 이 책을 공부해 나가면서 다양한 도구의 공통으로 지닌 것은 무엇인지 서로 구별되는 것은 무엇인지 그리고 어떻게 그러한 특성을 구현해냈는지 알아본다.

## 데이터 시스템에 대한 생각

일반적으로 데이터베이스, 캐시등은 데이터 저장이란 측면에서 표면적으로 비슷하더라도 매우 다른 접근 패턴을 갖고 있어 서로 다른 성능특성이 있기 때문에 구현방식이 매우 다르다.

그런데 왜 이를 데이터 시스템이라는 포괄적 용어로 묶어야할까?

첫 번째로 최근에 등장한 데이터 시스템 도구들은 다양한 사용사례에 최적화 되었기 때문에 더 이상 전통적인 분류에 딱 들어맞지 않는다. 메세지 큐로 사용하는 데이터 스토어인 레디스, 데이터 베이스처럼 지속성을 보장하는 메세지 큐인 아파치 카프카 등이 있다. 분류간의 경계가 흐려지고 있다.

두 번째로는 점점 더 많은 애플리케이션이 단일 도구로는 더이상 데이터 처리와 저장 모두를 만족 시킬 수 없는 광범위한 요구사항을 가지고 있다, 대신 작업(work)을 단일 도구에서 효율적으로 수행할 수 있는 태스크(task)로 나누고 **다양한 도구들은 애플리케이션 코드를 이용해 서로 연결 한다.**
예를 들어 아래 그림과 같이 전문검색서버의 경우 메인 데이터 베이스와 동기화된 캐시나 색인을 유지하는 것은 보통 애플리케이션 코드의 책임이다.

![system_architecture 예시
참조: Data-Intensive Applications 5page

**이제부터 개발자는 애플리케이션 개발자뿐만 아니라 데이터 시스템 설계자이기도 하다.**

데이터시스템이나 서비스를 설계할 떄 까다로운 문제가 많이 생긴다.  
내부적으로 문제가 있어도 데이터를 정확하고 완전하게 유지하려면 어떻게 해야 할지?  
일관되게 좋은 성능은 어떻게 제공할 수 있을지?  
부하증가를 다루기 위해 어떻게 규모를 확장할까?  
서비스를 위해 좋은 API는 어떤 모습일까?

이 책에서는 대부분의 소프트웨어 시스템에서 중요하게 여기는 세가지 관심사에 중점을 둔다.

```
신뢰성(Reliability)
하트웨어나 소프트웨어 결함, 인적 오류 같은 역경에 직면하더라도 시스템은 올바르게 동작해야 한다.

확장성(Scalability)
시스템의 데이터의 양, 트래픽 양, 복잡도가 증가해도 이를 처리할 수 있는 적절한 방법이 있어야한다.

유지보수성(Maintainability)
모든 사용자가 시스템 상 에서 생산적으로 작업할 수 있게 해야 한다.
```

## 신뢰성이란?

우리가 소프트웨어에게 가지는 일반적인 기대치는 다음과 같다

```
-애플리케이션은 기대한 기능을 수행한다.
-시스템은 예상치 못한 사용에도 대처할 수 있다.
-성능은 예상된 부하와 데이터 양에서 충분한 사용례를 만족한다.
-시스템은 허가되지 않은 접근과 오남용을 방지한다.
```

이 모든 것이 “working correctly” 의미하는 경우 **“무언가 잘못되더라도 지속적으로 올바르게 동작함(continuing to work correctly, even when things go
wrong)”** 을 신뢰성의 의미로 이해할수 있다.

잘못될 수 있는 일을 결함(fault) 이라 부른다.

이것을 예측하고 대측할 수 있는 시스템을 결함성(fault-tolerent) 또는 탄력성(resilent)을 지녔다고 말한다.

결함(fault)은 장애(failure)와 동일하지 않다.

일반적으로 **결함은 사양에서 벗어난 시스템의 한 구성 요소로 정의된다.** 그러나 장애는 **사용자에게 필요한 서비스를 제공하지 못하고 시스템 전체가 멈춘 경우다.**  
결함 확률을 0으로 줄이는 것은 불가능 하다. 그럼으로 결함으로 장애가 발생하지 않게끔 내 결함성 구조를 설계하는 것이 필요하다. 즉 신뢰 할 수 없는 것으로 신뢰 할 수 있는 시스템구축을 하는 것이 필요하다.

**tip 카오스 몽키란?**  
넷플릭스의 카오스 몽키는 고의적으로 개별 프로세스를 무작위로 죽여 테스트해서 이것을 처리하는 접근 방식이다.
"무기를 든 야생 원숭이가 데이터센터(또는 클라우드 영역)에 들어와 무작위로 인스턴스를 파괴하고 케이블을 끊더라도 중단 없이 고객에게 서비스를 계속 제공한다는 개념"

다음으로 해결책이 있는 결함유형 몇가지를 다뤄 보겠다.

### 하드웨어 결함

하드디스크는 우리의 생각보다 높은비율의 결함율을 가지고 있다. 고장, 램문제, 정전, 등 규모가 큰 데이터 센터에서 이런일은 늘상일어 난다. 이로인한 시스템 장애를 줄이기 위한 첫 번째 대응 으로는  
첫번째 대응책으로 각 하드웨어 구성요소에 중복을 추가하는 방법이 있다.

```
디스크는 RAID 구성으로 설치
서버는 이중전원 디바이스
hot-swap이 가능한 CPU
데이터 센터는 건전지와 예비 디젤 발전기
```

위와 같이, **하나의 요소가 죽으면 복구/교체 되는 동안 중복된 구성 요소를 대신 사용할 수 있게 한다**

최근까지 단일 장비의 전체 장애는 드물었어서, 대부분의 애플리케이션은 하드웨어 구성 요소의 중복(한번의 중복!)으로 충분했다.
그러나 데이터의 양과 계산 요구가 늘어나면서 더 많은 장비를 사용하게 되었고, 하드웨어 결함율도 함께 증가했다. AWS와 같은 클라우드 플랫폼은 가상 인스턴스가 예고없이 사용불가가 되는 경우도 있다. 유연성과 탄력성이 단일 장비의 신뢰성보다 우선적으로 설계되었기 때문이다.
따라서 하드웨어 자체의 중복성을 추가하거나 소프트웨어 내결함성 기술을 사용하는 시스템으로 점점 옮겨가고 있다.

이러한 시스템은 또 하나의 장점은 장비를 재부팅 해야하는 경우등에 중단시간 없이 한 노드씩 패치해서 패치를 적용할 수 있다. 단일서버는 중단시간이 필요

### 소프트웨어 오류

또다른 종류의 결함으로 시스템 내 체계적오류가 있다.

```
- 특정 잘못된 입력으로 인하여 모든 인스턴스 서버가 죽는 버그 ex)리눅스 커널 버그 2012년 6월 30일 윤초
- CPU 시간, 메모리, 디스크 공간, 네트워크 대역폭 등 공유자원을 과도하게 사용하는 일부 프로세스
- 시스템의 속도가 느려져 반응이 없거나 잘못된 응답을 반환하는 서비스
- 하나의 결함이 다른 구성 요소의 결함의 원인이 되어서 발생하는 연쇄 장애
```

이런 버그는 특정 상황에 의해 발생하기 전까지 오랫동안 나타나지 않는다. 소프트웨어 오류는 신속한 해결책이 없다.

```
- 시스템의 가정과 상호작용에 대해서 주의깊게 생각하기
- 빈틈없는 테스트
- 프로세스 격리
- 죽은 프로세스 재시작 허용
- 프로덕션 환경에서 시스템 동작의 측정
- 모니터링
- 분석하기
```

위와 같은 작은 일 들이 문제 해결에 도움을 줄 수 있을 뿐이다.

### 인적 오류

사람은 미덥지 않다. 그럼에도 어떻게 시스템을 신뢰성있게 만들 수 있을까? 좋은 시스템은 다양한 접근방식을 결합한다.

```
- 오류의 가능성을 최소화하는 방향으로 시스템을 설계하라. 잘 설계된 추상화, API, 관리 인터페이스를 사용하자. "옳은 일"은 쉽게하고 "잘못된 일"은 막을 수 있다.
- 사람이 가장 많이 실수하는 장소에서 사람으로 인해 장애가 발생할 수 있는 부분을 분리하다. 특히 실제 데이터를 볼 수 있지만 사용자에게는 영향이 없는 비 프로덕션 샌드박스를 제공하라.
- 단위 테스트, 전체 시스템 통합 테스트, 수동 테스트까지 모든 수준에서 철저히 테스트하라.
- 인적오류를 빠르고 쉽게 복구할 수 있게 하라 설정 변경은 빠르게 롤백 가능하게, 새로운 코드는 서서히 롤 아웃하게.
- 성능 지표와 오류율 같은 상세하고 명확한 모니터링 대책을 마련하라.
- 조작 교육과 실습을 시행하라.
```

### 신뢰성은 얼마나 중요할까?

비지니스 애플리케이션 버그는 생산성 저하의 원인이고 전자 상거래 사이트의 중단은 매출 손실과 명성 타격이란 면에서 많은 비용이 발생한다. 또한 "중요하지 않은"애플리케이션도 사용자에 대한 책임이 있다.
신뢰성은 발전소, 항공 교통 관제 소프트웨어만을 위한 것이 아니다. 더 많은 수 의 일상적인 애플리케이션도 모두 안정적으로 작동해야한다.

## 확장성이란?

**확장성**은 증가한 부하에 대한 시스템 능력을 설명하는 데 사용하는 용어지만 시스템에 부여하는 일차원적인 표식이 아님에 주의하자. “X는 확장 가능하다” 또는 “Y는 확장 가능하지 않다” 같은 말은 의미가 없다.
확장성을 논한다는 것은 **“시스템이 특정 방식으로 커지면 이에 대처하기 위한 선택은 무엇인가?” 와 “추가 부하를 다루기 위해 계산 자원을 어떻게 투입할까”? 같은 질문을 고려한다는 의미다.**

### 부하 기술하기

무엇보다 시스템의 현재 부하를 간결하게 기술해야 한다. 그래야 부하 성장 질문(부하가 2배로 커지면?)을 논의할 수 있다. 부하는 부하 매개변수(load parameter) 라 부르는 몇 개의 숫자로 나타낼 수 있다.
가장 적합한 부하 매개변수 선택은 시스템 설계에 따라 달라진다. 예를들어

```
- 웹서버의 초당 요청수(TPS)
- DB에 읽기 대 쓰기 비율
- 대화방의 동시 활성 사용자
- 캐시 적중률 등이 있다.
```

평균적인 경우가 중요할 수 있고 소수의 극단적인 경우가 병목의 현상의 원인 일 수 있다.

트위터의 예를 들어보자. 트위터의 주요 두가지 동작은 다음과 같다.

```
트윗 작성
팔로워에게 새로운 메시지를 게시. (평균 초당 4.6k 요청. 피크일때 초당 12k 이상)
홈 타임라인 (read)
팔로우한 사람이 작성한 트윗을 볼 수 있다.(평균 초당 300k요청)
```

트윗 작성의 초당 12k 쓰기는 쉽다. 하지만 트위터의 확장성문제는 트윗 양이 아닌 팬 아웃(fan-out)때문이다. 트위터의 경우 홈 타임라인의 질의부하를 견뎌내기 위하여 개별 사용자의 홈 타임라인 캐시를 유지하는데 만약 한 사용자가 트윗을 작성했다면 해당 사용자를 팔로우 하는 사람을 모두 찾아 각자의 홈타임라인 캐시에 새로운 트윗을 삽입하는 방식이다 그러면 홈 타임라인의 읽기요청은 요청 결과를 미리 계산했기 때문에 비용이 저렴하다. 트윗게시 요청은 쓰기요청에 읽기요청이 수백배 많기 때문에 쓰기시점에 더 많은 일을 하는 것이 바람직하다. 여기서 이 방식의 불리한 점은 트윗 작성이 많은 부가 작업(fan-out)을 필요로 하다는 것이다. 만약 평균 75명의 팔로워를 가지는 일반인이 아닌 팔로워가 3000만명이 넘는 유명인의 경우는 어떻게 될까?
위의 트위터 예시에 있어서 사용자당 팔로워의 분포는 팬 아웃 부하를 결정하기 때문에 확장성을 논의할때 핵심 부하 매개 변수가 된다. 트위터 예시의 최종전개는 혼합형(hybrid)으로 간다. 대부분의 사용자들은 해당 사용자가 작성할 때 팔로워에 캐시에 해당 내용이 기록되지만 특정 사용자(유명인)의 경우 이 팬아웃에서 제외된다. 그들의 트윗은 팔로워가 읽는시점에 DB에서 별도로 가져와 홈타임라인에 합쳐진다.

### 성능 기술하기

일단 시스템 부하를 기술하면 부하가 증가할 때 어떤 일이 일어나는지 조사할 수 있다.

다음 두가지 방법을 살펴보자.

부하 매개변수를 증가시키고 시스템 자원은 변경하지 않고 유지하면 시스템 성능은 어떻게 영향을 받을까?
부하 매개변수를 증가시켰을 때 성능이 변하지 않고 유지되길 원한다면 자원을 얼마나 많이 늘려야 할까?
일괄 처리 시스템은 처리량 즉 초당 초리할 수 있는 데이터, 작업 수행 할 떄 걸리는 전체 시간에 관심을 두지만, 온라인 시스템에서 더 중요한 것은 응답 시간이다.

:::tip
지연 시간과 응답 시간을 종종 같은 뜻으로 사용하지만 동일하지 않다.
응답 시간은 클라이언트에서 본 관점으로, 요청을 처리하는 실제 시간 외에도 네트워크 지연과 큐 지연도 포함한다.
지연 시간은 요청이 처리되길 기다리는 시간으로, 서비스를 기다리며 휴지Latent 상태인 시간을 말한다.
:::
클라이언트가 반복해서 동일한 요청을 보내도 매번 응답시간이 다르다.
따라서 응답 시간은 단일 숫자가 아니라 분포로 생각해야 한다.

분포에서 산술평균을 사용할 수 있지만 일반적으로 좋은 지표가 아니기에 백분위를 사용하는 편이 좋다.
상위 95퍼센트가 1.5초라면, 100개 요청 중 95개는 1.5초 미만이고, 5개는 1.5초 이상이다.

백분위는 서비스 수준 목표(service level objective, SLO)와 서비스 수준 협약서(service level agreement, SLA)에 자주 사용하고 기대 성능과 서비스 가용성을 정의하는 계약서에서 자주 등장한다. 다음 문장은 SLA의 한 예다. “응답 시간 중앙 값이 200밀리초 미만이고 99분위가 1초 미만인 경우 정상 서비스 상태로 간주하며 서비스 제공 시간은 99.9% 이상이어야 한다.”

이런 지표는 클라이언트의 기대치를 설정해 SLA 를 지키 못하면 고객이 환불을 요구할 수 있게 한다. 아마존은 내부서비스 요구사항을 99.9로 정의한다. 보통 응답시간이 가장 느린 요청을 경험한 곡ㄱ들은 많은 구매를 해서 고객중에서 계정에 가방 많은 데이터를 가지고 있어서다.

### 부하 대응 접근 방식

Scaling up(vertical scaling), scaling out(horizontal scaling) 과 같은 방법이 있다.
용량 확장 / 수직확장 (scaling up)
장비를 고사양으로 이동
규모 확장 / 수평확장 (scaling out)
다수의 사양 낮은 장비 을 구분지어 이야기하곤한다.
적절한 사양의 장비 몇대가 다량의 사양 낮은 장비보다 간단하고 저렴하다. 그러므로 항상 이를 실용적으로 조합해서 사용해야한다.

- 다수의 장비에 부하를 분산하는 아키텍처는 비공유(shared-nothing) 아키텍처라 부른다.

탄력적인 시스템은 부하 증가를 감지하면 컴퓨팅 자원을 자동으로 추가한다. 그렇지 않은 시스템은 수동으로 확장해야 한다.
탄력적인 시스템은 부하를 예측할 수 없을 만큼 높은 경우 유용하지만 수동으로 확장하는 시스템이 더 간단하고 운영상 예상치 못한 일이 더 적다.

다수의 장비에 Stateless 서비스를 배포하는 일은 간단하다. 그러나 Stateful 시스템을 분산 설치하는 것은 복잡하다.

특정 애플리케이션에 적합한 확장성을 갖춘 아키텍처는 주요 동작이 무엇이고 잘 하지 않는 동작이 뭇언지에 대한 가정을 바탕으로 구축한다. 이 가정은 곧 부하 매개변수가 된다.

일부 시스템은 탄력적이다. (AWS 를 생각해보자.) 즉, 부하증가를 감지하면 컴퓨팅 자원을 자동으로 추가할 수 있다. 탄력적인 시스템은 부하를 예측 못할 만큼 높을때 유용하지만, 수동 확장이 더 간단하고 운영상의 예상치 못한 일이 적다
최근 분산시스템을 위한 도구와 추상화가 좋아지면서 대규모 데이터를 다루지 않는 사용 사례에사도 분산데이터 시스템이 기본아키텍처로 자리 잡을 가능성이 있다.
시스템의 아키텍처는 해당 시스템을 사용하는 애플리케이션에 특화되어있다. 범용적이고 모든 상황에 맞는(one-size-fits-all) 확장 아키텍처는 없다(비공식적으로magic scaling source)는 없다. 아케 텍처를 결정하는 요소는

```
읽기양
쓰기 양
저장할 데이터 양
데이터 복잡도
응답시간 요구사항
접근패턴 등

```

이 있다
예를 들어 1kB 요청을 초당 1B 처리하는 시스템과 2GB 요청을 분당 3건 처리하는 시스템은 같은 데이터 처리량이라고 해도 매우 다르다.
특정 애플리케이션에 적합한 확장성을 갖춘 아키텍처는 주요 동작이 무엇이고 잘 하지 않는 동작이 무엇인지의 대한 가정을 바탕으로 구축한다 이 가정은 곧 부하 매개변수가 된다.
. 이 가정이 잘못되면 확장에 대한 엔지니어링 노력이 헛수고가 되고 역효과를 낳을 수 있다.

확장성을갖춘 아키텍처가 특정 애플리케이션에 특화 됐을 지라도 이런 아키텍처는 보통 익숙한 패턴으로 나열된 범용적인 구성요소로 구축한다

## 유지보수성이란?

소프트웨어 비용의 대부분은 초기 개바이 아니라 지속해서 이어지는 유지 보수에 들어간다. 대부분의 개발자들은 소위 레거시 시스템의 유지 보수 작업을 좋아하지 않는다. 그렇기에 유지보수의 고통을 초쇠소하하고 레거시 소프트 웨어를 직접 만들지 않게끔 소프트웨어를 설계할 수 있다. 쏫 드래야 한다 그러기 위해 주위를 기울어야할 시스템 설계원칙 은 다음 3가지 이다.

```
운용성 운영팀이 시스템을 원활하게 운영할 수 있도록 쉽게 만들어라.
단순성 시스템 복잡도를 줄여서 새로운 엔지니어가 시스템을 이해하기 쉽게 만들어라.
발전성 엔지니어가 이후에 쉽게 시스템을 변경할 수 있게 만들어라.
```

신뢰성 확장성을 달성하기 위한 쉬운 해결책은 없다. 그러니 위의 3가지를 두고 시스템을 새생각하려 노력해야함

### 운용성: 운영의 편리함 만들기

시스템이 원활하게 작동하려면 운영팀이 필수다. 운영팀은 대개 다음과 같은 일을 한다.

시스템 상태를 모니터링하고 서비스를 복원
시스템 장애, 성능 저하들의 원인을 추적
보안패치
문제를 예측해 미리 해결
배포, 설정 관리등을 위한 모범 사례와 도구 마련
...

좋은 운영성이란 동일 반복 태스크를 쉽게 수행하게끔 만든다는 점이다.

```
좋은 모니터링으로 내부 시스템에 대한 가시성 제공
표준 도구를 이용해 자동화와 통합
좋은 문서
개별 장비 의존성을 회피.
```

### 단순성: 복잡도 관리

복잡도 수렁에 바진 소프트웨어를 'big ball of mud'커다란진흙덩어리로 묘사하곤한다. 복잡성은 다양한 증상으로 나타난다.

```
모듈 간 강한 결합
상태 공간의 급증
일관성 없는 네이밍과 용어
성능 문제 해결이나 임시 방편인 특수 사례
```

복잡도 때문에 시스템 유지보수가 어려우면, 예산과 일정이 초과된다. 때문에 복잡도는 반드시 줄이고 단순화해야한다. 그러나 이 말이 기능을 줄인다는 의미는 아니다. 오히려 우발적 복잡도 (소프트웨어가 풀 문제에 있는 것이 아니고, 구현에서 발생하는 복잡도)를 잡는다는 의미에 가깝다. 단순성이 구축하려는시스템의 핵심 목표여야한다.

우발적 복잡도를 잡는 가장 최상의 도구는 추상화다. 좋은 추상화는 깔끔하고, 직관적이며 많은 세부 구현을 숨길 수 있다. 또한 좋은 추상화는 다른 다양한 애플맄이션에서도 사용가능하다. 예를 들어 고수준 PL 은 기계 언어, CPU 레지스터 ... 등을 숨긴 추상화다. 우리는 고수준 언어로 프로그래밍해도 기계어를 사용한다. 단지 직접하지 않을 뿐이다.

좋은 추상화를 찾기는 어렵다. 이제 책 전반에 걸쳐 좋은 추상화를 살펴보자.

### 발전성: 변화를 쉽게 만들기

시스템의 요구사항은 끊임없이 변하기 마련이다. 조직 프로세스 측면에서 agile은 변화에 적응하기 위한 프레임 워크를 제공한다. 그러나 agile에 대한 설명은 대부분 작은 규모에 초점을 맞추고 있다. 이 책에서는 대규모 수준에서 민첩성을 높이는 방법을 찾는다. 데이터 시스템 변경을 쉽게 하고 변화된 요구 사항에 시스템을 맞추는 방법은 시스템의 간단함과 추상화와 밀접한 관련히 있다. 간단하고 이해하기 쉬운 시스템은 대개 복잡한 시스템보다 ㅜ정하기 쉽다.

## 정리

애플리케이션이 유용하려면 다양한 요구사항을 충족시켜야 한다. 다양한 요구사항에는 기능적 요구사항과 비기능적 요구사항이 있다.
비기능적 요구사항에는 보안, 신뢰성, 법규준수, 확장성, 호환성, 유지보수성 같은 것이 있다.

신뢰성은 결함이 발생해도 시스템이 올바르게 동작하게 만든다는 의미다. 결함은 하드위어와 소프트웨어 버그와 사람에게 있을 수 있다. 내결함성 기술은 최종사용자에게 특정 유형의 결함을 숨길 수 있게 해준다.

확장성은 부하가 증가해도 좋은 성능을 유지하기 위한 전략을 의미한다. 확장성을 설명하려면 부화와 성능을 설명하는 방법과 지표가 필요하다 . 예시로 성능측정 방법으로 응답시간 백분위가 있다. 확장가능한 시스템에서는 부하가 높은 상태에서 신뢰성 유지하기 위해 처리용량을 추가할수 있다.

유지보수성의 본질은 엔지니어와 운영 팀의 삶을 개선하는 데 있다. 좋은 추상화는 복잡도를 줄이고 쉽게 시스템을 변경할 수 있게 하며 새로운 사용 사례에 적용하는 데 도움이 된다.
좋은 운용성이란 시스템의 건강 상태를 잘 관찰할 수 있고 시스템을 효율적으로 관리하는 방법을 보유한다는 의미다.

안타깝게도 애플리케이션을 신뢰할 수 있고 확장 가능하며 유지보수하기 쉽게 만들어주는 간단한 해결책은 없지만 여러 애플리케이션에서 계속 재현되는 특정 패턴과 기술이 있다.

이 후 책에서 데이터 시스템 몇가지를 예제로 살펴보고 이런 목표를 위해 데이터 시스템이 어떻게 작동하는지 또 3부에서는 여러구성요소가 함께 작동하도록 구성한 시스템 패턴을 살펴본다.

## 오늘의 공부 한마디

1. 최근 작업을 하면서 대용량데이터를 처리하지 못해서 서버다운 등의 문제가 일어난 일을 직접 겪은 만큼
   확장성에 관한 공부내용이 와닿는다. 개발을 시작하기 전에 사용하는구조가 하려고하는 작업에 잘맞는지. 따져보는것.
   그를 위해 데이터 베이스등의 선택이유가 명확해야 한다는 것을 명심하기. 앞으로 공부하면서 또 현장에서 작업하면서
   해당부분에 대한 경험과 지식을 쌓아가는게 중요하다.
2. 애플리케이션 코드레벨에서 할 수 있는건 단순성과 발전성이 아닐까. 단순성에 목표를 둬서 코드 만들기! 어렵게 표현하지 말고 누가 봐도 이해할 수 있는 코드를 만드는게 왜 중요 한가.
   앞으로 나의 코딩 목표는 단순하고 발전가능성있는 코드를짜는것, 단순하고 발전가능성있는 시스템을 설계하는것이다
