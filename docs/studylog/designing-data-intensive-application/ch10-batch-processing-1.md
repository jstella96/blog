---
order: 10
icon: creative
title: 일괄처리(1) 유닉스 철학
category:
  - IT서적
tag:
  - chapter 10
---

## 개요

큰 애플리케이션에서는 데이터를 접근하고 처리하는 데 다양한 방법이 필요하다 하지만 동시에 다른 모든 요구사항을 만족하는 하나의 데이터베이스는 없다. 대게 여러 다른 데이터스토어, 색인, 캐시, 분석 시스템 등 몇 가지를 조합해서 사용하고 한 저장소에서 다른 저장소로 데이터를 이동하는 메커니즘을 구현한다 3부에서는 데이터 모델도 다르고 최적화된 접근 양식도 다른 여러 데이터 시스템을, 일관성 있는 하나의 애플리케이션 아키텍처로 통합하는 문제를 검토한다.

### 레코드 시스템 vs 파생데이터 시스템

데이터를 저장하고 처리하는 시스템은 크게 두 분류로 나눌 수 있다.

- 레코드 시스템  
  믿을 수 있는 데이터 버전을 저장한다. 레코드 시스템은 진실의 근원이라고도 하는데 예를 들어 사용자의 입력과 같은 새로운 데이터가 들어오면 먼저 레코드 시스템에 저장된다. 각 사실은 일반적으로 정규화를 거쳐 정확하게 한번 표현된다. 레코드 시스템과 다른 시스템 간에 차이가 난다면 정의에 따라 레코드 시스템이 옳다.

- 파생 데이터 시스템  
  파생 데이터 시스템에서는 데이터는 다른 시스템에 존재하는 데이터를 가져와 특정 방식으로 변환하고 처리한 결과다. 파생 데이터를 잃게 되더라도 원천 데이터로부터 다시 생성할 수 있다. 대표적인 예가 캐시인데 필요한 데이터가 캐시에 있다면 제공하고, 그렇지 않다면 기반 데이터베이스를 거쳐 제공할 수 있다. 비정규화 값, 색인, 구체화 뷰 등이 있다.
  파생 데이터는 기존 데이터를 복제한다는 의미에서 중복(redundant)이다. 하지만 읽기 질의 성능을 높이는 데 종종 필수적이다. 비정규화 과정을 통해 생성한다.
  시스템 아키텍처를 망치지 않고 명료성을 갖추기 위해서는 데이터가 어떤 데이터로부터 파생됐는지를 명확히 해야 한다.

### 시스템 유형 3가지 분류

웹과 점점 늘어나고 있는 HTTP/REST 기반 API 때문에 요청/응답 방식의 상호작용이 매우 흔해져있지만. 이 방법이 시스템을 구축하는 유일한 방법은 아니다. 시스템을 3가지 유형으로 구분하면 위와 같이 구분할 수 있다.

1. 서비스(온라인 시스템) : 서비스는 클라이언트로부터 요청이나 지시가 올 때까지 기다린다. 요청이 들어오면 서비스는 가능한 빨리 요청을 처리해서 응답을 되돌려 보내려 한다. 쥬용 성능 지표 = 응답 시간

2. 일괄 처리 시스템(오프라인 시스템) : 일괄 처리 시스템은 매우 큰 입력 데이터를 받아 데이터를 처리하는 작업을 수행하고 결과 데이터를 생산한다. 주요 성능 지표 = 처리량 (입력 데이터 중 특정 크기만큼 처리할 때 걸리는 시간)

3. 스트림 처리 시스템(준 실시간 시스템) : 일괄처리 시스템과 마찬가지로 요청에 대해 응답 하지 않으며 입력데이터를 소비하고 출력 데이터를 생산한다. 일괄 처리 작업은 정해진 크기의 입력 데이터를 대상으로 작동하지만 스트림 처리는 입력 이벤트가 발생한 직후 바로 작동한다. 일괄 처리 기반이나, 지연 시간이 낮다.

### 일괄처리

이 중 이번장에 살펴볼 일괄처리는 신뢰성있고, 확장가능하며 유지보수성 있는 애플리케이션을 구축하는데 매우 중요한 구성요소다.
2004년에 발표된 일괄처리 알고리즘인 맵리듀스(Map Reduce)는 약간의 과장을 보태 구글을 대규모로 확장가능하게한 알고리즘 으로 불렸다.
일괄처리는 사실 컴퓨터 연산에 있어 매우 오래된 형태이다. 이번 장에서는 맵리듀스를 알아보자. 그전에 표준 유닉스 도구를 사용해 데이터를 처리하는 방법을 알아본다. 유닉스 철학을 되새겨 보는것도 나름 가치가 있다. 유닉스가 주느 아이디어와 교훈이 대규모 이기종 분산 시스텝으로 그대로 이어지기 때문이다.

## 유닉스 철학

10장은 유닉스 도구와 그의 철학에 대해 알아보는 것부터 시작한다. 유닉스는 1970년대에 만들어진 운영체제다. 오래된 시스템이 지금까지 쓰인다는건 그만큼 유닉스가 주는 아이디어와 교훈이 강력하다는 의미기도 하다. 오늘날 사용되는 대규모 분산 시스템에서도 유닉스 철학이 이어지는 도구들이 많다.

> “다른 방법으로 데이터 처리가 필요할 때 정원 호스와 같이 여러 다른 프로그램을 연결하는 방법이 필요하다”  
> -유닉스 파이프를 발명한 더그 맥글로이(1964)

1978년 기술된 유닉스 철학은 아래와 같다.

1. 각 프로그램이 한 가지 일만 하도록 작성하라. 새 작업을 하려면 기존 프로그램을 고쳐 새로운 “기능”을 추가해 프로그램을 복잡하게 만들기보다는 새로운 프로그램을 작성하라.

2. 모든 프로그램의 출력은 아직 알려지지 않은 다른 프로그램의 입력으로 쓰일 수 있다고 생각하라. 불필요한 정보로 출력이 너저분해서는 안 된다.

3. 소프트웨어를 빠르게 써볼 수 있게 설계하고 구축하라. 거슬리는 부분은 과감히 버리고 새로 구축하다.

4. 프로그래밍 작업을 줄이려면 미숙한 도움보단 도구를 사용하라.

자동화, 빠른 프로토 타이핑, 증분 반복, 실험 친화, 큰 프로젝트를 청크로 나누어 처리하기와 같은 방법은 오늘날의 애자일 및 DevOps 운동과 매우 흡사하다.

bash 같은 유닉스 셸을 사용하면 작은 프로그램들을 가지고 놀랄만큼 강력한 데이터 처리 작업을 쉽게 구성할 수 있다. 프로그램중 다수를 다른 그룹에 속하는 사람들이 만들었지만 유연한 방식으로 함께 조합할 수 있다. 유닉스에 이런 결합성을 부요하는 것은 무엇일까?

### 1. 동일 인터페이스

어떤 프로그램의 출력을 다른 프로그램의 입력으로 쓰고자 한다면 프로그램은 같은 데이터 형식을 사용해야 한다. **특정 프로그램이 다른 어떤 프로그램과도 연결 가능 하려면 프로그램 모두가 같은 입출력 인터페이스를 사용해야 한다는 의미다.**

유닉스에서 인터페이스는 파일이다. 파일은 단지 순서대로 정렬된 바이트의 연속이다. 이처럼 단순해서 같은 인터페이스로 파일시스템의 실제 파일, 프로세스 간의 통신 채널, 장치 드라이버, TCP 연결을 나타내는 소켓 등 다른 여러 가지 것을 표현할 수 있다.

### 2. 로직과 연결의 분리

유닉스 도구의 다른 특징으로 표준 입력과 표준 출력을 사용한다는 점이다. 파이프는 한 프로세스의 표준출력을 다른 프로세스의 표준입력과 연결한다. 이때 중간 데이터를 디스크에 쓰지 않고 작은 인메모리 버퍼를 사용해 프로세스 간 데이터를 전송한다. 프로그램은 입력이 어디서부터 들어오는지 출력이 어디로 나가는지 신경 쓰거나 알 필요조차 없다.( 이런 형태를 느슨한 결합, 지연 바인딩, 제어 반전이라 한다.) 프로그램에서 입출력을 연결하는 부분을 분리하면 작은 도구로부터 큰 시스템을 구성하기가 훨씬 수월하다. 어떤 프로그램이든 표준 입출력만 지키면 데이터 처리 파이프라인에 바로 끼워 사용할 수 있다.

### 3. 투명성과 실험

유닉스는 진행 사항을 파악하기가 상당히 쉽다.

1. 명령에 들어가는 입력 파일은 일반적으로 불변으로 처리된다.

2. 어느 시점이든 파이프라인을 중단하고 출력을 파이프를 통해 less로 보내 원하는 형태의 출력이 나오는지 확인할 수 있다. 디버깅할 때 매우 유용

3. 특정 파이프라인 단계의 출력을 파일에 쓰고 그 파일을 다음 단계의 입력으로 사용할 수 있다. 전체 파이프라인을 다시 시작하지 않고 다음 단계부터 재시작 가능

**유닉스 도구를 사용하는데 가장 큰 제약은 단일 장비에서만 실행된다는 점이다.** 이 점이 하둡 같은 도구가 필요한 이유다.
