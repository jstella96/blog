---
order: 2
icon: lock
title: 데이터 모델과 질의 언어
category:
  - IT서적
editLink: false
breadcrumb: false
contributors: false
---

> The limits of my language mean the limits of my world.

## :memo:개요

대부분의 애플리케이션은 하나의 데이터 모델을 다른 데이터 모델 위에 계층을 둬서 만든다. 각 계층의 핵심적인 문제는 다음 하위 계층 관점에서 데이터 모델을 표현하는 방법이다.

- 애플리케이션 개발자는 현실을 보고 객체나 데이터구조 또한 이러한 데이터 구조를 다루는 API를 모델링 한다.
- 데이터 구조를 저장할 때는 JSON, 관계형 데이터베이스 테이블 혹은 그래프 모델 같은 범용 데이터 모델(general data model)로 표현한다.
- 데이터베이스 소프트웨어를 개발하는 엔지니어는 general-purpose data를 메모리나 디스크 또는 네트워크 상위 바이트 단위로 표현하는 방법을 결정한다.
- 더 낮은 관점에서 보면 하드웨어 엔지니어는 전류, 빛의 파동 자기장 등의 관점에서 바이트를 표현한다.

보다시피 각 계층은 명확한 데이터 모델을 제공해 하위 계층의 복잡성을 숨긴다. 이 추상화는 다른 그룹에서 일을 하는 사람들이 (예를 들어 데이터 베이스 엔지니어와 애플리케이션 개발자) 효율적으로 함께 일 할 수 있게끔 한다.

데이터 모델은 소프트웨어가 어떻게 작성됐는지 뿐만 아니라 해결하려는 문제를 어떻게 생각해야 하는지, **그 위에서 소프트웨어가 할 수 있는 일과 할 수 없는 일에 지대한 영향을 주므로애플리케이션에 적합한 데이터 모댈을 선택하는 작업은 상당히 중요하다.**

이 장에서는 다양한 범용 데이터 모델(general data model)을 살펴본다. 특히 관계형 모델, 문서 모델, 그래프 기반 데이터 모델에 중점을 둔다.
각 데이터 모델을 특징, 사용하는 이유와 얻을 수 있는 이점을 명확히 알아야 우리가 만드려는 애플리케이션에 맞춰서 선택할 수 있다.

## 관계형 모델과 문서 모델

데이터 모델의 차이점에만 집중한다.

결론부터 말하자면 문서데이터 모델을 선호하는 주요 이유는 스키마 유연성, 지역성에 기인한 더 나은 성능 때문이고, 일부 애플리케이션의 경우 애플리케이션에서 사용하는 데이터 구조와 더 가깝기 때문이다(일대다 관계)
관계형 모델은 조인, 다대일, 다대다 관계를 더 잘 지원한다.

만약 애플리케이션의 데이터가 이력서와 같이 문서와 비슷한 구조 즉 일대다 트리 관계로 한번에 전체 트리를 적재 할 수 있는 경우라면 문서 모델을 이용하는 것이 좋다.
이 경우 관계형모델을 사용할 경우 테이블을 분리하게 되면서 불필요하게 복잡한 애플리케이션 코드를 발생시키게된다.

문서 내 중첩 항목을 바로 참조할 수 없다는 문제를 가지고 있지만 너무 깊게 중첩되지 않으면 일반적으로 문제가 되지 않는다.

문서 데이터 베이스의 미흡한 조인조건은 문제일 수 도 아닐수도 있다. 어떤 애플리케이션에서 사용 하느냐의 문제인데 예를 들어 어떤시점에 발생한 이벤트를 기록하는 문서데이터 베이스를 사용하는 분석 애플리케이션은 다대다 관계가 결 코 필요하지 않다.

하지만 애플리케이션에서 다대다 관계를 사용한다면 문서모델보다 관계형데이터베이스가 낫다.

애플리케이션 내에서 조인을 대체할 다중요청을 만들어 낼 수 있지만 복잡성이 애플리케이션으로 이동될뿐 아니라 데이터 베이스 내 특화된 코드로 수행되는 조인보다 느리다.

일반적으로 어떤 데이터 모델이 애플리케이션 코드를 더 간단하게 만들 수 있는가에 대한 답은 없다.
데이터 항목간에 존재하는 관계 유형에 따라 다르다.
상호연결이 많은 데이터의 경우 문서모델은 곤란하고 관계형모델은 무난하며 그래프 모델은 매우 자연스럽다.

### 문서 모델의 특징

스키마 유연성

### 관계형모델

- 오늘날 가장 잘 알려진 모델은 관계형 모델을 기반으로 한 SQL 이다.
- 데이터(SQL에서 테이블 이라고 불린다) 관계(relation)로 구성되고 각 관계는 순서 없는 튜플(tuple 혹은 row)의 모음이다.
- 관계형 데이터베이스의 근원은 1960-1970년대 메인프레임에서 수행된 비즈니스 데이터 처리에 있다.
  - 트랜잭션 처리(은행 거래, 항공 예약, 창고 재고 보관)
  - 일괄처리(송장작성, 급여지불, 보고)
- 당시 다른 데이터베이스를 사용하는 애플리케이션 개발자는 데이터베이스의 내부 데이터 표현에 대해 많이 고민해야 했지만 관계형 모델의 목표는 정리된 인터페이스 뒤로 구현 세부 사항을 숨기는 것이다.

### NoSQL

Not Only SQL로 해석된다.
NoSQL DB를 채택한 데는 다음과 같은 원동력이 있다.

- 대규모 데이터셋이나 매우 높은 쓰기 처리량 달성에 대해 RDB보다 더 뛰어난 확장성이 필요(Scalability)
- 오픈소스에 대한 선호도 확산
- 관계형 모델에서 지원하지 않는 특성화된 질의 동작(specialized query operation)
- 관계형 스키마의 제한에 대한 불만, 더 동적이고 풍부해진 데이터 모델에 대한 바람

### 객체 관계형 불일치

해당 관점에서 문서 모델이 가진 이점을 살펴보자.

OOP 언어로 개발한 애플리케이션과 SQL 데이터 모델.

임피던스 불일치(impedance mismatch) : 데이터를 RDB에 저장 할 경우 애플리케이션 코드와 DB 모델 객체(table, row, column) 사이에 전환 계층이 필요하다. 이러한 모델 사이 분리를 의미한다.
관계형 매핑(ORM) 프레임워크는 전환 계층의 필요한 상용구코드(boilerplate code) 코드 양을 줄여주지만 두 모델 사이의 차이를 완벽히 숨길 순 없다.
누군가의 이력서 프로필을 예시로 든다면. 일반 적인 이력서는 이력이 하나이상이며 학력과 연락처 정보도 다양할 수 있다. 사용자와 항목은 일대다(one-to-many)관계이다. 이런 관계는 아래와 같은 방법들로 표현할 수 있다.

- SQL에선 정규화 표현으로 직위, 학위, 학력, 연락처 정보를 개별 테이블에 저장하고 외래키를 이용해 user 테이블을 참조한다. (가장 전통적인 RDB 설계)
- SQL에 xml, json, object 타입이 지원되면서 하나의 row에 다중 값을 저장할 수 있고 문서 내 질의와 색인이 가능해졌다.
- 직업, 학력, 연락처 정보를 json 이나 xml로 부호화해 DB 텍스트 칼럼에 저장하여 반환한다 이러면 부호화된 칼럼을 질의하는데 데이터 베이스를 사용할 수 없다.

<사진 넣기>
이력서는 모든 내용을 갖추고 있는 문서 이기 때문에 JSON이 표현에 적합하다. 몽고DB 카우치DB등의 문서지향 데이터 베이스에서 Json 데이터 모델을 지원한다.

- JSON 표현은 multi-table 스키마보다 더 나은 지역성(locality)을 갖는다.
- 다중질의 수행하거나 다중 조인이 필요없다. 모든 관련 정보가 한 곳에 있어 질의하나로 충분하다.
- 일대다 관계는 의미상 데이터 트리 구조와 같다.

## 다대일과 다대다 관계

위의 이력서에서 지역(region_id) 와 (industry_id)는 평문이 아닌 ID로 주어졌다. 이렇게 주어지는 이유는 아래와 같은 장점이 있다.

- 일관된 스타일과 철자
- 모호함 회피(서울, 서울시, 서울특별시와 같은 단어를 정제하여 사용)
- 갱신의 편의성
- 현지화 지원, 표준목록을 현지화하여 지역과 업계를 사이트를 보는 사람의 언어로 표시
- 더 나은검색 제공(워싱턴 주에 있는 자선가)

중복의 문제: Id를 사용하면 정보를 한곳에만 저장하고 해당 Id를 사용하면 되지만, 텍스트로 저장하면 모든 레코드에 중복이 발생한다. 만약 정보가 중복되어있으면 변경사항 발생시 모든 중복항목을 변경해야하므로 쓰기 오버헤드와 불일치 위험이 있다.
이처럼 **중복된 데이터를 정규화하려면 다대일(many-to-one) 관계가 필요하지만 문서 모델에는 적합하지 않다. 조인에 대한 지원이 약하기 때문이다.**

## 문서 데이터베이스는 역사를 반복하고 있나?

문서 DB와 NoSQL은 DB에서 다대다 관계를 표현하는 좋은 방법이 무엇인지에 대한 논쟁을 다시 열었다.

1970년대 비지니스 데이터 처리를 위해 가장 많이 사용한 데이터 베이스는 IBM의 정보 관리 시스템으로
IMS는 계층 모델을 사용했다. 계층 모델은 Json모델과 굉장히 비슷하다. IMS도 일대다 관계에서는 잘 동작했지만 다댇다 관계표현은 어려 웠으며, 조인은 지원하지 않았다.
개발자는 데이터를 중복할지, 또 다른 레코드의 참조를 수동으로 해결해야할지 결정해야했다.
이러한 고민은 오늘날 문서DB를 사용하는 개발자가 풀어야할 문제와 매우 비슷하다.

계층 모델의 한계 극복을 위해 제안된 해결책들로는 관계형모델(SQL이 되어 세상을 지배)과 네트워크 모델(잊혀짐)이 있었다.
두 모델이 해결하려는 문제가 오늘날에도 여전히 관련히 많다. 현재관점에서 살펴보자.

### 네트워크 모델

코다실 위원회에서 표준화 했다.네트워크 모델을 코다실 모델이라고도 부른다.
네트워크 모델은 계층 모델을 일반화한다.

네트워크 모델에서 레코드 간 연결은 외래 키보다는 프로그래밍 언어의 포인터와 더 비슷하다.
레코드에 접근하는 유일한 방법은 root record에서부터 경로를 따라 내려가는 것이다.
원하는 데이터에 대한 경로가 없다면 곤란해진다.
접근 경로를 수작업으로 지정해주는 노력이 필요.

계층 모델에서 tree 구조는 정확히 하나의 부모가 있지만, 네트워크 모델에선 다중 부모가 있을 수 있다.
네트워크 모델에서 레코드에 접근하는 방법은 root record 에서 연속된 연결경로를 따르는 방법이다.
만약 레코드가 다중 부모를 갖는다면 다양한 관계를 모두 추적해야 한다는 문제가 있다.
원하는 데이터에 대한 경로가 없다면 접근 경로변경할 수 있지만 큰 비용이 들어간다. 데이터 모델을 바꾸는 작업은 어려운일이였다.

### 관계형 모델

관계(테이블
query optimizer가 있어 접근 경로를 자동으로 만든다.
즉, 관게형 모델은 애플리케이션에 새로운 기능을 추가하는 작업이 쉽다.

네트워크 모델과 대조적으로 관계형 모델이 하는 일은 알려진 모든 데이터를 배치하는 것이다. )는 단순히 튜플(로우)의 컬렉션이 전부이다.
얽히고 설킨 구조에서 데이터를 보고 싶을 때 따라가야할 복잡한 경로가 없다.
질의 최적화기는 질의의 어느 부분을 어떤 순서로 실행할지 결정하고 사용할 색인을 자동으로 결정한다. 이 선택은 실제로 "접근경로"ㅣ다.
하지만 차이점은 접근경로를 개발자가 아니라 질의 최적화기가 자동으로 만든다는 점이다!

새로운 방식으로 데이터에 질의하고 싶은경우 색인을 선언하기만 하면 질의가 가장 적합한 색인을 사용하므로 새로운 기능을 추가하는 것이 훨씬 쉽다

### 문서 DB와의 비교

문서 DB는 별도 테이블이 아닌 상위레코드 내에 중첩된 레코드를 저장한다는 측면에서 계층 모델과 비슷한 점이 있지만,
다대일/다대다 관계를 표현할 때 관계형 DB와 문서DB는 근본적으로 다르지 않다.
둘다 관련 항목은 고유한 식별자로 참조한다. 관계형 모델에서는 외래키라고 부르고 문서 모델에서는 문서참조(document reference)라 부른다.
이 식별자는 조인이나 후속질의를 사용해 읽기 시점에 확인한다.

코다실 전철 밟고 있지 X

## 관계형 DB와 오늘날의 문서 DB

문서 데이터 모델을 선호하는 이유
스키마 유연성
지역성에 기인한 더 나은 성능
애플리케이션의 데이터가 문서와 비슷한 구조인 경우
관계형 기법은 다루기 힘든 스키마, 불필요한 코드를 많이 발생시킨다.
관계형 모델을 선호하는 이유
join
다대다/다대일 관계를 더 잘 지원
데이터를 위한 질의 언어
선언형 언어
선언형 언어(SQL 같은)의 장점들

DB 엔진의 상세 구현이 숨겨져 있어 질의를 변경하지 않고도 DB 시스템의 성능을 향상시킬 수 있다.
SQL은 순서를 보장하지 않으므로 순서를 바꾸어도 상관없다.
SQL이 기능적으로 더 제한적이라는 사실은 DB가 자동으로 최적화할 수 있는 여지를 더 많이 준다는 의미.
선언형 언어는 병렬 실행에 적합하다.
오늘날의 CPU는 클록 속도를 높여 빨라지기보다, 코어를 더 추가해 빨라지는 방식을 선택.
명령형 코드는 명령어를 순서대로 수행하도록 지정되기 때문에 병렬 처리가 어렵다.
선언형 언어는 보고 싶은 결과의 패턴만 지정하기 때문에 병렬 실행으로 더 빨라질 가능성이 크다.
MapReduce Querying
맵리듀스는 선언형 언어와, 완전한 명령형 질의 API의 중간 정도에 있음.
맵리듀스는 함수형 프로그래밍 언어에 있는 map 과 reduce 함수를 기반으로 한다.

## 그래프형 데이터 모델

관계형 모델은 다대다 관계를 다루지만, 데이터 간 연결이 더 복잡해지면 그래프로 데이터를 모델링하는 쪽이 더 자연스러울 수 있다.

그래프의 구성 요소

정점(vertex)
간선(edge)
그래프 모델링의 예

소셜 그래프
정점: 사람
간선: 사람들이 서로 알고 있음
페이스북
간선: 어떤 사람들이 서로 친구인가?
간선: 어떤 사람이 어떤 장소에서 체크인했는가?
간선: 어떤 사람이 어떤 포스트에 좋아요를 눌렀는가?
간선: 어떤 사람이 어떤 포스트에 코멘트를 작성했는가?
웹 그래프
정점: 웹 페이지
간선: 다른 페이지에 대한 HTML 링크
page rank로 검색 결과 순위 결정
도로나 철도 네트워크
정점: 교차로
간선: 도로/철로 선 등
자동차 네비게이션 등에서 최단 경로 검색
속성 그래프
속성 그래프의 정점

고유한 식별자
유출(outgoing) 간선 집합
유입(incoming) 간선 집합
속성 컬렉션(키-값 쌍)
속성 그래프의 간선

고유한 식별자
꼬리 정점: 간선이 시작하는 정점
머리 정점: 간선이 끝나는 정점
두 정점 간 관계 유형을 설명하는 레이블
속성 컬렉션(키-값 쌍)
이대로 RDB에 저장하면, 속성 컬렉션은 json 타입을 쓰면 된다.

CREATE TABLE vertices (
vertex_id integer PRIMARY KEY,
properties json
);

CREATE TABLE edges (
edge_id integer PRIMARY KEY,
tail_vertex integer REFERENCES vertices (vertex_id),
head_vertex integer REFERENCES vertices (vertex_id),
label text,
properties json
);

CREATE INDEX edges_tails ON edges (tail_vertex);
CREATE INDEX edges_heads ON edges (head_vertex);
속성 그래프의 특징은 다음과 같다.

정점은 다른 정점과 간선으로 연결된다.
특정 유형과의 관계를 제한하는 스키마가 없다.
정점이 주어지면, 유입/유출 간선을 효율적으로 찾을 수 있다.
정점을 따라 그래프를 순회할 수 있다.
다른 유형의 관계에 서로 다른 레이블을 사용하면 단일 그래프에 다른 유형의 정보를 저장하면서도 데이터 모델을 깔끔하게 유지할 수 있다.
Cypher 질의 언어
선언형 질의 언어

생략

SQL의 그래프 질의
그래프 데이터를 관계형 구조로 넣어도 SQL을 사용해 질의할 수 있을까?

SQL:1999 이후, 가변 순회 경로에 대한 질의 개념은 재귀 공통 테이블 식(recursive common table expression)(WITH RECURSIVE 문)을 사용해 표현할 수 있다.
Cypher로는 쉬운데 SQL로는 많이 어려움. 게다가 길다.
트리플 저장소(Triple-Stores)와 스파클(SPARQL)
속성 그래프 모델과 비슷하다.

비슷한 개념을 다른 용어로 표현한 느낌.
트리플 저장소는 모든 정보를 주어(subject), 서술어(predicate), 목적어(object)로 저장한다.
주어는 그래프의 정점과 같다.
목적어는 두 가지 중 하나다.
값
그래프의 다른 정점
예 : John, likes, bananas
예 : John, age, 30
예 : John, marriedTo, Loui
시맨틱 웹(semantic web)
웹 사이트는 사람이 읽을 수 있도록 정보를 보여주고 있다.
컴퓨터도 판독 가능하도록 정보를 보여주면 어떨까?
생략

스파클(SPARQL) 질의 언어
생략

데이터로그(Datalog)
생략

Links

-===두 가지 주요 갈래가 있음
문서 DB : 문서와 문서 간 관계가 거의 없는 경우를 대상으로 한다.
그래프 DB : 모든 자료가 잠재적으로 관련 있는 경우를 대상으로 한다.
