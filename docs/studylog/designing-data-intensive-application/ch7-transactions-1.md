---
order: 7
icon: creative
title: 트랜잭션(1) ACID
category:
  - IT서적
tag:
  - chapter 7
---

## 개요

**트랜잭션은 애플리케이션에서 몇 개의 읽기와 쓰기를 하나의 논리적 단위로 묶는 방법이다.** 개념적으로 한 트랜잭션 내의 모든 읽기와 쓰기는 한 연산으로 실행된다. 트랜잭션은 전체가 성공(commit)하거나 실패(어보트, 롤백)한다.

트랜잭션은 데이터 베이스에 접속하는 애플리케이션에서 프로그래밍 모델을 단순화하려는 목적으로 만든 것이다.
트랜잭션을 쓰면 애플리케이션에서 오류 처리를 하기가 훨씬 단순해진다. 어떤 연산은 성공하고 어떤 연산은 실패하는 경우처럼 부분적인 실패를 걱정할 필요가 없기 때문이다. 또한
트랜잭션을 사용함으로써 애플리케이션에서 어느 정도 잠재적인 오류와 동시성 문제를 무시할 수 있다. 데이터 베이스에서 이런 일을 도맡아 주기 때문이다(안전성 보장, safety guarantee)

그러나 모든 애플리케이션에서 트랜잭션이 필요하지는 않으며 때로는 트랜잭션적인 보장을 완화하거나 아예 쓰지 않는 게 이득일 수 있다.(성능 향상, 가용성을 높을 수 있다.)
트랜잭션이 필요한지 알기 위해서는 트랜잭션이 제공하는 안전성 보장에는 어떤 것이 있으며 이와 관련된 비용은 무엇인지 정확하게 이해해야 한다.

거의 모든 관계형 데이터에서는 트랜잭션을 지원한다. 그러나 2000년대 후반에 비 관계형(NoSQL) 데이터 베이스가 인기를 얻기 시작했다. 이들이 새로운 데이터 모델을 제시하며 기본적으로 복제와 파티셔닝 기능을 제공하였다. 새로운 세대의 데이터베이스 중 다수는 트랜잭션을 완전히 포기하거나 과거에 인식되던 것보다 약한 보장을 의미하는 단어로 트랜잭션의 의미를 재정의 했다.
이렇게 새로 탄생한 분산 데이터 베이스가 홍보되면서 트랜잭션은 확장성의 안티테제이며 어떤 대규모 시스템이라도 높은 성능과 고가용성을 유지하려면 트랜잭션을 포기해야 한다는 믿음이 널리 퍼졌다.
반면 트랜잭션적인 보장은 "값진 데이터"가 있는 "중대한 애플리케이션"에 필수적인 요구사항이라는 주장이 있다. 두 가지다 완전한 과장이다.

다른 모든 기술적 설계 선택과 마찬가지로 트랜잭션은 이점과 한계가 있다. 이 트레이드오프를 이해하기 위해서는 정상적인 운영상황관 다양한 극단적이고 현실적인 환경에서 트랜잭션이 제공하는 보장의 세부 사항을 살펴보자.

## ACID

트랜잭션이 제공하는 안전성 보장은 흔히 원자성(Atomicity), 일관성(Consistency), 격리성(Isolation), 지속성(Durability)을 위미 하는 약어인 ACID로 잘 알려져 있다.
그러나 현실에서는 데이터베이스마다 ACID구현이 제각각이다. 오늘날 시스템이 'ACID'를 준수'한다고 할 때 그 시스템에서 실제로 어떠한 것을 기대할 수 있는지는 분명하지 않다.

:::info
ACID 표준을 따르지 않는 시스템은 때로 BASE라고 불린다

- Basically Available : 기본적으로 가용성을 제공하고
- Soft state 유연한 상태를 가지며
- Eventual consistency 최종적 일관성을 가진다

위와 같은 의미를 가진다. ACID보다 더 모호하다

:::

### 1. 원자성(Atomicity)

여러 쓰기 작업이 하나의 원자적인 트랜잭션으로 묶이고 트랜잭션이 완료(커밋)되거나 결함이 발생하여 해당 트랜잭션의 작업이 중단(어보트)되거나 둘 중 하나여야 한다.

오류가 생겼을 때 트랜잭션을 중단(어보트)하고 해당 트랜잭션에서 기록한 모든 내용을 취소하는 능력이 ACID의 원자성의 결정적인 특성이다. 그 의미에서 **Abortability**가 더 나은 단어이다.

### 2. 일관성(Consistency)

ACID에서의 일관성은 데이터가 항상 어떠한 불변식을 만족한다는 보장이다. 예를 들면 회계 프로그램에서 차변과 대변이 항상 같아야 한다 같은 것이 있다.
트랜잭션이 항상 불변식이 유효한 데이터 베이스에서 시작하고 트랜잭션에서 실행된 모든 쓰기가 유효성을 보존한다면 불변식이 항상 만족된다고 확신할 수 있다.
그러나 일관성은 애플리케이션의 불변식 개념에 의존하고 일관성을 유지하도록 트랜잭션을 올바르게 정의하는 것은 애플리케이션의 책임이다. 데이터베이스는 불변식을 위반하는 잘못된 데이터를 쓰지 못하게 막을 수 없다.(단 외래키, 유일성 등은 데이터베이스에서 보장하는 특수한 경우 있기는 하다)
**ACID에서 일관성만 유일하게 애플리케이션의 속성이다.**

### 3. 격리성(Isolation)

여러 트랜잭션이 동시에 같은 레코드에 접근하면 동시성 문제(경쟁 조건)에 맞닥뜨린다. ACID에서 격리성은 동시에 실행되는 트랜잭션은 서로 격리된다는 것을 의미한다. 트랜잭션은 다른 트랜잭션을 방해할 수 없다.

### 4. 지속성(Durability)

트랜잭션이 성공적으로 커밋됐다면 하드웨어 결함이 발생하거나 데이터베이스가 죽더라도 트랜잭션에서 기록한 모든 데이터는 손실되지 않는다는 보장이다.
단일 노드에서는 쓰기전로그(Write-ahead log), 복제 기능이 있는 DB에서는 데이터가 성공적으로 다른 노드 몇 개에 복사되었다는 것을 의미한다. 지속성을 보장하기 위해 데이터베이스는 트랜잭션이 성공적으로 커밋되었다고 보고하기 전에 쓰기나 복제가 완료될 때까지 기다려야 한다.
그러나 완벽한 지속성은 존재하지 않는다. 모든 하드디스크와 백업이 동시에 파괴되면 당연히 데이터베이스가 해줄 수 있는 건 아무것도 없다.

## 다중 객체 트랜잭선

우리가 주목해야 하는 것은 원자성과 격리성이다. 클라이언트가 한 트랜잭션 내에서 쓰기를 여러 번 하면
원자성과 격리성은 다음과 같은 것들을 보장해주어야 한다.

- 원자성 : 쓰기를 이어서 실행하는 도중 오류가 발생하면 트랜잭션은 어보트되어아하고 그때까지 쓰인 내용은 폐기되어야 한다. 데이터 베이스는 전체 반영되거나 전체 반영이 되지 않아야 한다. 부분 실패를 걱정할 필요가 없어야 한다.

- 격리성: 동시에 실행되는 트랜잭션들은 서로를 방해하지 말아야 한다. 예를 들어 한 트랜잭션이 여러 번 쓰기 작업을 한다면 다른 트랜잭션은 그 내용을 전부 볼 수 있든지 아무것도 볼 수 없어야 한다. 일부분만 볼 수 있으면 안 된다.
  다중 객체 트랜잭션은 흔히 데이터의 여러 조각이 동기화된 상태로 유지돼야 할 때 필요하다. 이메일 테이블을 비 정규화해서 이메일과 읽지 않은 이메일 카운트가 다른 테이블에 있고, 각각 업데이트해야 되는 경우를 생각해보자.

만약 사용자가 이메일은 삽입이 되었는데 아직 카운트가 갱신되지 않아서 사용자가 삽입된 이메일과 갱신된 개수를 다르게 보면 혼란이 생길 것이다. 격리성은 이러한 경우가 생기지 않도록 보장한다. 사용자가 두 가지 값이 다 경신된 후를 보거나 모두 보지 못하게 하고 일관성이 깨진 중간은 보지 않게 해 준다.

원자성은 만약 이메일이 삽입된 후 카운트 갱신을 실패할 경우에는 트랜잭션이 어보트 되고 삽입된 이메일은 롤백되는 것을 보장해준다.

다중 객체 연산을 위해서는 읽기 및 쓰기 연산들이 동일한 트랜잭션에 속하는지 알아낼 수단이 있어야 한다.
관계형 데이터베이스의 경우는 전형적으로 어떤 특정 연결 내에서 BEGIN TRANSACTION문, COMMIT문 사이의 모든 것은 같은 트랜잭션에 속하는 것으로 여겨진다. 반면 비 관계형 데이터베이스는 이런 식으로 연산을 묶는 방법이 없는 경우가 많다.

많은 분산 데이터 스토어는 다중 객체 트랜잭션을 포기했다. 여러 파티션에 걸쳐서 구현하기가 어렵고, 가용성과 성능이 필요한 곳에서 방해가 되기도 하기 때문이다. 다중 객체 트랜잭션이 필요할까? 키-값 데이터 모델과 단일 객체 연산만으로는 애플리케이션을 구현할 수 없을까 물론 단일 객체의 삽입 갱신 삭제 연산만으로 충분한 사용 사례가 있지만 많은 다른 경우에는 다중 객체 쓰기 작업은 트랜잭션이 필요하다.

- 서로 참조하는 여러 레코드를 삽입할 때 참조 키는 항상 올바르고 최신 정보를 반영해야 한다. 다 중 객체 트랜잭션은 참조가 유효한 상태로 유지되도록 보장해준다.
- 비 정규화된 여러 테이블의 데이터들을 한 번에 갱신해야 할 때(질의 속도 문제로 인하여 읽지 않은 이메일 개수를 별도에 필드에 저장했을 때)
- 보조 색인이 있는 경우 값이 변경될 때 색인도 함께 갱신되어야 한다.

트랜잭션이 없더라도 이런 애플리케이션들을 구현할 수 있지만 원자성이 없으면 오류처리가 훨씬 더 복잡해지고, 격리성이 없으면 동시성 문제가 생길 수 있다.

:::info 단일 객체 쓰기
원자성과 격리성은 단일 객체를 변경하는 경우에도 적용된다. 여러 클라이언트에서 동시에 같은 객체에 쓰려고 할 때 갱신 손실을 방지하므로 유용하다. 그러나 일반적으로 쓰이는 의미의 트랜잭션이 아니다.
**트랜잭션은 보통 다중 객체에 대한 다중 연산을 하나의 실행 단위로 묶는 메커니즘**으로 이해된다.
:::

## 오류와 어보트 처리

트랜잭션의 핵심 기능은 오류가 생기면 어보트되고 안전하게 재시도할 수 있다는 것이다. ACID 데이터 베이스는 이 철학을 바탕으로 한다.
어보트된 트랜잭션을 재시도하는 것은 간단하고 효과적인 오류 처리 메커니즘이니만 완벽하지 않다.

- 트랜잭션이 실제론 커밋되었지만 네트워크 문제로 클라이언트는 실패했다고 생각하여 중복 처리가 될 수 있다. 애플리케이션에 추가적인 중복 제거 메커니즘이 없다면!
- 오류가 과부하 때문이라면 트랜잭션 재시도는 문제를 악화시킬 수 있다. 해결하려면 재시도 횟수 제한, 지수적 백오프(1차시도 1초, 2차시도 2초, 3차시도 4초..), 과부하 관련 오류 다른 오류와 별도 처리 등 방법을 사용할 수 있다.
- 일시적인 오류(데드락, 네트워크 오류, 시스템 장애)만 가치 있고 영구적인 오류(제약 조건 위반)는 재시도해도 소용이 없다.
- 트랜잭션이 데이터베이스 외부에도 부수 효과가 있다면 트랜잭션 어보트 될 때도 부수 효과가 실행될 수 있다(ex. 이메일 보내기)

:::info 최선을 다하는 원칙
모든 시스템이 이 철학을 따르진 않는다. 특히 리더 없는 복제를 사용하는 데이터 스토어는 "최선을 다하는(best effort)" 원칙을 기반으로 훨씬 더 많은 일은 한다. 요약하면 데이터 베이스는 가능한 모든 것을 할 것이며 그 때문에 오류가 발생하면 이미 한일은 취소하지 않는다" 따라서 오류 복구는 애플리케이션에게 책임이 있다.
:::
