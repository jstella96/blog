---
order: 8
icon: creative
title: 트랜잭션(2) 동시성 문제
category:
  - IT서적
tag:
  - chapter 7
---

## 동시성문제(경쟁조건)

동시성 문제는 트랜잭션이 다른 트랜잭션에서 동시에 변경한 데이터를 읽거나 두 트랜잭션이 동시에 같은 데이터를 변경하려고 할 때 나타난다.

데이터 베이스는 오랫동안 트랜잭션 격리를 제공함으로써 애플리케이션 개발자들에게 동시성 문제를 감추려고 했다. 이론상으로는 격리성은 동시성 문제가 없는 것처럼 행동할 수 있게해준다. 그러나 현실에서의 격리는 그렇게 간단한 문제가 아니다. 직렬성 격리는 성능 비용이 있고 많은 데이터 베이스는 그 비용을 지불하려 하지 않는다. 따라서 어떤 동시성 이슈로부터는 보호해주지만 모든 이슈로부터는 보호해주지는 않는 완화된 격리 수준을 사용하는 시스템들이 흔하다.

동시성 문제의 종류를 잘 이해하고 방지하는 방법을 배울 필요가 있다. 이해를 바탕으로 적합한 도구를 써서 신뢰성 있고 올바르게 동작하는 애플리케이션을 만들 수 있다. 현장에서 사용되는 완화된 격리 수준을 몇 가지 살펴보고 발생할 수 있는 경쟁조건과 발생할 수 없는 경쟁조건을 살펴보자 또한 직렬 성 격리에 대해서도 알아보자

:::info 직렬 성 격리
데이터 베이스가 여러 트랜잭션들이 직렬적으로 실행되는 것(즉 동시성 없이 한 번에 트랜잭션 하나만 실행)과 동일한 결과가 나오도록 보장한다는 것을 의미.
:::

## 완화된 격리 수준

### 1. 커밋 후 읽기(read committed)

가장 기본적인 트랜잭션 격리 수준으로 다음 두 가지를 보장해준다.

더티 읽기 방지 : 데이터베이스에서 읽을 때 커밋된 데이터만 본다.  
더티 쓰기 방지 : 데이터베이스에 쓸 때 커밋된 데이터만 덮어쓰게 된다.

- **더티 읽기 방지**  
  다른 트랜잭션에서 아직 커밋되지 않은 데이터를 보는 경우를 더티 읽기라고 부른다.
  커밋 후 읽기 격리 수준에서는 더티 읽기를 막아야 한다. 트랜잭션이 쓴 내용은 커밋된 후에야 다른 트랜잭션에게 보여야 한다. 더티 읽기를 막는 게 유용한 이유는 다음과 같다.

  - 트랜잭션이 여러 객체를 갱신하는데 더티 읽기가 생기면 일부는 갱신된 값을, 일부는 갱신되지 않은 값을 볼 수 있게 된다.
  - 트랜잭션이 어보트되면 롤백해야 하는데 더티 읽기가 생기면 실제로 커밋되지 않은 롤백된 데이터를 볼 수 있게 된다.

- **더티 쓰기 방지**  
  아직 커밋되지 않은 트랜잭션에서 쓴 데이터를 새로운 트랜잭션이 덮어쓰는 경우를 더티 쓰기라고 한다.
  커밋 후 읽기 격리 수준에서는 더티 쓰기를 막아야 한다.
  보통 먼저 쓴 트랜잭션이 커밋되거나 어보트될 때까지 두 번째 쓰기를 지연시킨다.

  - 다른 트랜잭션에서 충돌하는 쓰기를 실행할 때 더티 쓰기가 있으면 내용이 섞일 수 있다

- **커밋 후 읽기 구현**

  - 더티 쓰기 방지 구현:  
    가장 흔한 방법으로 로우 수준 잠금을 사용해 더티 쓰기를 방지한다.
    트랜잭션에서 특정 객체를 변경하고 싶다면 잠금을 획득해야 하고 트랜잭션이 커밋되거나 어보트될 때까지 잠금을 보유하고 있어야 한다. 오직 한 트랜잭션만 어떤 주어진 객체에 대해 잠금을 보유할 수 있다.

  * 더티 읽기 방지 구현:  
    더티 읽기의 경우는 잠금을 사용하면 읽기만 실행하는 여러 트랜잭션들이 오랫동안 실행되는 쓰기 트랜잭션 하나가 완료될 때까지 기다려야 할 수 있기 때문에 응답 시간에 해를 끼친다.
    그렇기 때문에 데이터베이스는 쓰인 모든 객체에 대해 과거에 커밋된 값과 현재 쓰기 잠금을 가진 트랜잭션에서 쓴 새로운 값을 모두 기억한다.
    한 객체에 쓰기 잠금을 가진 트랜잭션이 실행 중인 동안 그 객체를 읽는 다른 트랜잭션은 해당 객체가 커밋하기 전까지는 과거에 커밋된 값을 읽게 된다.

### 2. 스냅숏 격리

- 비반복 읽기(nonrepeatable read)  
  은행 계좌 A, B에 각각 500달러씩 있고 A 계좌에서 B계좌로 100달러를 전송하는 트랜잭션을 실행한다고 하자. 두 계좌에서 데이터를 받아와야 하는데, b계좌의 검색은 트랜잭션이 처리되고 있는 순간에 계좌 잔고를 보고 A 계좌는 는 커밋된 후에 계좌잔고를 보게 된다면 A 계좌는 400달러, B계좌는 500달로 나와 총 900달러가 있는 것처럼 보일 수도 있다. 이런 현상을 비반복 읽기(nonrepeatable read) 혹은 읽기 스큐(read skew)라고 하며 커밋 후 읽기에서는 이런 현상을 막을 수 없다.
  시간이 지나 트랜잭션이 커밋되면 이런 현상은 사라지지만 이런 일시적인 비일관성도 감내할 수 없는 경우가 있다.(ex. 백업, 분석 질의, 무결성 확인)
- 스냅숏 격리  
  스냅숏 격리는 위와 같은 문제를 해결할 수 있는 가장 흔한 해결책이다. **각 트랜잭션은 데이터베이스의 일관된 스냅숏으로부터 읽는다(특정 시점에 고정된 DB). 즉 트랜잭션은 시작할 때 데이터베이스에 커밋된 상태였던 모든 데이터를 본다. 데이터가 나중에 다른 트랜잭션에 의해 바뀌더라도 각 트랜잭션은 특정한 시점의 과거 데이터를 볼뿐이다.**(시간을 맞추는 것)
  스냅숏 격리는 PostgreSQL, InnoDB 저장소 엔진을 쓰는 MySQL, Oracle 등에서 지원한다.

- 스냅숏 격리 구현  
  스냅숏 격리에서는 더티 쓰기를 방지하기 위해서는 쓰기 잠금을 사용한다. 그러나 읽을 때는 아무 잠금도 필요 없다. 성능 관점에서 스냅숏 격리의 핵심 원리는 읽는 쪽에서 쓰는 쪽을 결코 차단하지 않고 쓰는 쪽에서 읽는 쪽을 결코 차단하지 않는다는 것이다.
  스냅숏 격리를 구현하기 위해서는 객체마다 커밋된 버전 여러 개를 유지할 수 있어야 한다. 진행 중인 여러 트랜잭션에서 서로 다른 시점의 데이터 베이스 상태를 봐야 할 수도 있기 때문이다.
  데이터베이스가 객체의 여러 버전을 함께 유지하는 기법을 다중 버전 동시성 제어(multi-version concurreny control, MVCC)라고 한다.
  스냅숏 격리를 지원하는 저장소 엔진은 보통 커밋 후 읽기 격리를 위해서도 MVCC를 사용한다. 커밋된 버전과 아직 커밋되지 않은 버전 2가지로 커밋 후 읽기 격리를 구현할 수 있다.
  스냅숏 격리 구현을 위해서는 트랜잭션 별로 계속 증가하는 고유한 트랜잭션 ID를 할당받는다. 트랜잭션이 데이터를 쓸 때마다 해당 트랜잭션 ID와 버전별 객체가 기록되어 트랜잭션에 따라 특정 버전의 객체들을 읽을 수 있도록 한다. 테이블의 각 로우에는 그 로우를 테이블에 삽입한 트랜잭션의 ID를 갖는 `created_by`필드가 있다 또한 `deleted_by`필드도 있다. 트랜잭션이 로우를 삭제하면 실제 DB에서는 지우지 않고 deleted_by필드를 삭제요청 트랜잭션의 ID로 설정한다. 나중에 아무 트랜잭션도 삭제된 데이터에 접근하지 않는 게 확실해지면 DB내의 가비지 컬렉션 프로세스가 지워졌다고 표시된 로우들을 지운다. 즉 데이터 갱신은 내부에서 삭제와 생성으로 변환된다 위의 계좌 문제에서 계좌 테이블에 있는 계좌 A의 경우 두 개의 로우를 가지게 된다. 트랜잭션이 삭제한 것으로 표시된 잔고 500달러 로우와 해당 트랜잭션이 생성한 잔고 400달러의 로우이다. 각 트랜잭션이 시작되는 시점에 실행 중인 트랜잭션들이 쓴 데이터와, 어보트 된 트랜잭션이 쓴 데이터, 트랜잭션 ID가 더 큰 트랜잭션이 쓴 데이터들은 후에 커밋 여부와 관련 없이 모두 무시된다.

스냅숏 격리는 유용한 격리 수준이며 특히 읽기 전용 트랜잭션에서 유용하다. 오라클에서는 직렬 성 PostgreSQL, MySQL에서는 반복 읽기(repeatable read)라고 표현한다.

### 3. 갱신 손실 방지

커밋 후 읽기와 스냅숏 격리는 주로 동시에 실행되는 쓰기 작업에서 읽기 전용 트랜잭션이 무엇을 볼 수 있는지에 대한 보장과 관련된 것이다.

동시 쓰기를 실행할 때 발생할 수 있는 문제는 무엇이 있을까. 더티 쓰기뿐만 아니라 동시에 실행되는 쓰기 트랜잭션 사이에 발생할 수 있는 충돌 상황들이 존재하며 가장 유명한 것이 갱신 손실(lost update) 문제이다.

갱신 손실 문제는 애플리케이션이 데이터베이스에서 값을 읽고 변경한 후 변경된 값을 다시 쓸 때 발생할 수 있다.(read-modify-write 주기). 두 트랜잭션이 동시에 해당 작업은 수행하는 경우 두 번째 쓰기 작업이 첫 번째 변경을 포함하지 않으므로 발생할 수 있다.
즉 두 클라이언트가 동시에 read-modify-write 주기를 실행할 때 한 트랜잭션이 다른 트랜잭션의 변경을 포함하지 않은 채로 다른 트랜잭션이 쓴 내용을 덮어써서 데이터가 손실되는 문제이다.

- 카운터 증가, 계좌잔고 갱신(현재 값 읽고 새 값 계산하고 갱신된 값 다시 써야 한다.)
- json문서 내에 있는 리스트에 엘리먼트 추가 등 복잡한 값을 지역적 변경
- 사용자 편집 내용 저장 시 전체 내용 보내서 덮어쓰는 로직으로 구현된 위키에서 두 명의 사용자 동시 편집

이처럼 갱신 손실 문제는 흔한 문제이기 때문에 다양한 해결책이 개발되었다.

- **원자적 쓰기 연산**  
   여러 데이터베이스에서 원자적 쓰기 연산을 제공하기 때문에 애플리케이션에서 read-modify-write 주기를 구현할 필요를 없애 준다.
  UPDATE counters SET value = value + 1 WHERE key = 'foo' 이 쿼리는 대부분의 관계형 데이터베이스에서 동시성 안전(concurrency-safe)하다.
  이 방법에서는 보통 객체를 읽을 때 그 객체에 독점적인 잠금을 획득해서 구현한다. 그래서 갱신이 적용될 때까지 다른 트랜잭션에서 그 객체를 읽지 못하게 한다.
- **명시적인 잠금**  
  데이터베이스에서 원자적 쓰기 연산을 제공하지 않는다면 애플리케이션에서 객체를 명시적으로 잠그는 방식으로 해결할 수 있다. 한 트랜잭션의 read-modify-write의 주기가 완료될 때까지 다른 트랜잭션이 동시에 같은 객체를 읽을 수 없고 기다려야 한다. 수동 잠금이 필요하다.(SELETE FOR UPDATE)
  애플리케이션 로직에 대해 신중하게 생각해야 한다. 어딘가 로직의 실수로 경쟁조건 유발하기 쉽다.

* **갱신 손실 자동 감지**  
  병렬 실행을 허용하도록 하고 트랜잭션 관리자가 갱신 손실을 발견 시 트랜잭션을 어보트 시키고 read-modify-write 주기를 재시도하도록 강제하는 방법이 있다.
  애플리케이션 코드에서 어떤 특별한 데이터 베이스 기능도 쓸 필요가 없게 도와주므로 매우 좋은 기능이다. 명시적인 잠금을 실수로 빼먹었을 때 자동으로 갱신 손실을 감지하여 트랜잭션을 어보트 시킬 수 있기 때문에 오류를 덜 방생시킨다.
  이 방법의 이점은 데이터 베이스가 이 확인을 스냅숏 격리와 결합해 효율적으로 수행할 수 있다는 것이다.
  실제로 PostgreSQL, 오라클, SQL 서버의 스냅숏 격리는 갱신 손실이 발생하면 자동으로 발견해서 해당 트랜잭션을 어보트 시키는 이 기능을 제공하지만 InnoDB 기반의 MySQL은 이 기능을 제공하지 않는다.
  ..

### 또 다른 문제들

- 쓰기쓰큐  
  트랜잭션이 무언가를 읽고 읽은 값을 기반으로 어떤 결정을 하고 그 결정을 데이터베이스에 쓴다. 그러나 쓰기를 실행하는 시점에는 결정의 전제가 더 이상 참이 아니다. 직렬 성 격리만 이런 현상을 막을 수 있다.

- 팬텀 읽기  
  트랜잭션이 어떤 검색 조건에 부합하는 객체를 읽는다. 다른 클라이언트가 그 검색 결과에 영향을 주는 쓰기를 실행한다. 스냅숏 격리는 간단한 팬텀 읽기는 막아주지만 쓰기 스큐 맥락에서 발생하는 팬텀은 색인 범위 잠금처럼 특별한 처리가 필요하다.

## 직렬성 격리

완화된 격리 수준은 모든 문제를 막아주지 못한다. 직렬성 격리만 모든 문제들을 보호해준다.

### 1. 트랜잭션 순서대로 실행

트랜잭션의 실행 시간이 아주 짧고 트랜잭션 처리량이 단일 CPU 코어에서 처리할 수 있을정도로 트랜잭션 처리량이 낮다면 아주 간단하고 효과적이다.

### 2. 2단계 잠금

수십 년 동안 직렬성을 구현하는 표준적인 방법이었지만 성능 특성 때문에 사용을 피하는 애플리케이션이 많다.

### 3. 직렬성 스냅숏 격리(SSL)

스냅숏 격리에 직렬성의 요소를 더한 것으로, 직렬성 스냅숏 격리는 완전한 직렬성을 제공하지만 스냅숏 격리에 비해 약간의 성능 손해만 존재한다
직렬성 스냅숏 격리 앞에서 언급한 결점 중 대부분을 피하는 상당히 새로운 알고리즘이다. 2단계 잠금은 비관적 동시성 제어 메커니즘이라면 직렬성 스냅숏 격리는 낙관적 동시성 제어 기법이다. 낙관적인 방법을 사용해서 트랜잭션이 차단되지 않고 진행할 수 있게 한다. 트랜잭션이 커밋을 원할 때 트랜잭션을 확인해서 실행이 직렬적이지 않으면 어보트 시킨다.
위험한 상황이 발생할 수 있을 때에도 일단 진행한다. 마지막에 커밋할 때 격리 위반을 확인하고 어보트한다. 쓰기 스큐처럼 질의 결과(전제 조건)와 쓰기 작업 사이 인과적 의존성이 있을 때, 전제 조건이 최신 결과가 아니면, 이를 감지해서 트랜잭션을 어보트시켜서 직렬성 격리를 제공한다.
어보트 비율은 SSI의 전체적인 성능에 큰 영향을 미친다. 이를테면 오랜 시간 동안 데이터를 읽고 쓰는 트랜잭션은 충돌이 나고 어보트되기 쉬워서, SSI는 읽기 쓰기 트랜잭션이 상당히 짧기를 요구한다 오래 실행되는 읽기 전용 트랜잭션은 괜찮다. 2PL이나 싱글 스레드 실행보다는 덜 민감하다.
