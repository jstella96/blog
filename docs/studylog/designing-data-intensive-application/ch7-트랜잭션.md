---
order: 7
icon: creative
title: 트랜잭션
category:
  - IT서적
editLink: false
---

==트랜잭션은 애플리케이션에서 몇 개의 읽기와 쓰기를 하나의 논리적 단위로 묶는 방법이다.== 개념적으로 한 트랙젝션 내의 모든 읽기와 쓰기는 한 연산으로 실행 된다. 트랜젝션은 전체가 성공(commit)하거나 실패(어보트,롤백)한다.

트랙젝션은 데이터 베이스에 접속하는 애플리케이션에서 프로그래밍 모델을 단순화하려는 목적으로 만든 것이다.
트랜잭션을 쓰면 애플리케이션에서 오류 처리를 하기가 훨씬 단순해진다. 어떤 연산은 성공하고 어떤 연산은 실패하는 경우처럼 부분적인 실패를 걱정할 필요가 없기 때문이다. 또한
트랜잭션을 사용함 으로써 애플리케이션에서 어느정도 잠재적인 오류와 동시성 문제를 무시 할 수 있다. 데이터 베이스에서 이런 일을 도맡아 주기 때문이다(안전성보장,safety guarantee)

그러나 모든 애플리케이션에서 트랜잭션이 필요하지는 않으며 때로는 트랜잭션적인 보장을 완화하거나 아예 쓰지 않는게 이득일 수 있다.(성능 향상, 가용성을 높을 수 있다.)
트랜잭션이 필요한지 알기위해서는 트랜잭션이 제공하는 안전성 보장에는 어떤 것이 있으며 이와 관련된 비용은 무엇인지 정확하게 이해해야한다.

거의 모든 관계형데이터에서는 트랜젝션을 지원한다. 그러나 2000년대 후반에 비관계형(NoSQL)데이터 베이스가 인기를 얻기 시작했다. 이들이 새로운데이터 모델을 제시하며 기본적으로 복제와 파티셔닝 기능을 제공하였다. 새로운 세대의 데이터베이스 중 다수는 트랜잭션을 완전히 포기하거나 과거에 인식되던 것보다 약한 보장을 의미하는 단어로 트랜잭션의 의미를 재정의 했다.
이렇게 새로 탄생한 분산 데이터 베이스가 홍보되면서 트랜잭션은 확장성의 안티테제 이며 어떤 대규모 시스템이라도 높은 성능과 고가용성을 유지하려면 트랜잭션을 포기해야 한다는 믿음이 널리 퍼졌다.
반면 트랜잭션적인 보장은 "값진데이터"가 있는 "중대한 애플리케이션"에 필수적인 요구사항이라는 주장이 있다. 두 가지다 완전한 과장이다.

다른 모든 기술적 설계선택과 마찬가지로 트랜잭션은 이점과 한계가 있다. 이 트레이드 오프를 이해하기 위해서는 정상적인 운영상황관 다양한 극단적이고 현실적인 환경에서 트랜잭션이 제공하는 보장의 세부 사항을 살펴보자.

## ACID

트랜잭션이 제공하는 안전성 보장은 흔히 원자성(Atomicity), 일관성(Consistency), 격리성(Isolation), 지속성(Durability)을 위미하는 약어인 ACID로 잘 알려져 있다.
그러나 현실에서는 데이터베이스마다 ACID구현이 제각각이다. 오늘날 시스템이 'ACID'를 준수'한다고 할때 그 시스템에서 실제로 어떠한 것을 기대할 수 있는지는 분명하지 않다.

:::note
ACID 표준을 따르지 않는 시스템은 때로 BASE라고 불린다

- Basically Available : 기본적으로 가용성을 제공하고
- Soft state 유연한 상태를 가지며
- Eventual consistency 최종적 일관성을 가진다
  는 뜻이다. ACID보다 더 모호하다

:::

### 원자성(Atomicity)

여러 쓰기 작업이 하나의 원자적인 트랜잭션으로 묶이고 트랜잭션이 완료(커밋)되거나 결함이 발생하여 해당 트랜잭션의 작업이 중단(어보트)되거나 둘 중 하나여야 한다.

오류가 생겼을 때 트랜잭션을 어보트하고 해당 트랜잭션에서 기록한 모든 내용을 취소하는 능력이 ACID의 원자성의 결정적인 특성이다. 그 의미에서 Abortability가 더 나은 단어이다.

### 일관성(Consistency)

ACID에서의 일관성은 데이터가 항상 어떠한 불변식을 만족한다는 보장이다. 예를 들면 회계 프로그램에서 차변과 대변이 항상 같아야 한다 같은 것이 있다.
트랜잭션이 항상 불변식이 유효한 데이터 베이스에서 시작하고 트랜잭션에서 실행된 모든 쓰기가 유효성을 보존한다면 불변식이 항상 만족된다고 확신할 수 있다.
그러나 일관성은 애플리케이션의 불변식 개념에 의존하고 일관성을 유지하도록 트랜잭션을 올바르게 정의하는 것은 애플리케이션의 책임이다. 데이터베이스는 불변식을 위반하는 잘못된 데이터를 쓰지 못하게 막을 수 없다.(단 외래키, 유일성 등은 데이터베이스에서 보장하는 특수한 경우 있기는 하다)
ACID에서 일관성만 유일하게 애플리케이션의 속성이다.

### 격리성(Isolation)

여러 트랜잭션이 동시에 같은 레코드에 접근하면 동시성 문제(경쟁 조건)에 맞닥뜨린다. ACID에서 격리성은 동시에 실행되는 트랜잭션은 서로 격리된다는 것을 의미한다. 트랜잭션은 다른 트랜잭션을 방해할 수 없다.

### 지속성(Durability)

트랜잭션이 성공적으로 커밋됐다면 하드웨어 결함이 발생하거나 데이터베이스가 죽더라도 트랜잭션에서 기록한 모든 데이터는 손실되지 않는다는 보장이다.
단일노드에서는 쓰기전로그(Write-ahead log), 복제 기능이 있는 DB에서는 데이터가 성공적으로 다른노드 몇 개에 복사 되었다는 것을 의미한다. 지속성을 보장하기위해 데이터베이스는 트랜잭션이 성공적으로 커밋되었다고 보고하기 전에 쓰기나 복제가 완료될 때까지 기다려야한다.
그러나 완벽한 지속성은 존재하지 않는다. 모든 하드디스크와 백업이 동시에 파괴되면 당연히 데이터베이스가 해줄 수 있는건 아무것도 없다.

### 다중 객체 트랜잭선

다중 객체 연산을 위해서는 읽기 및 쓰기 연산들이 동일한 트랜잭션에 속하는지 알아낼 수단이 있어야 한다. 관계형 데이터베이스에서는 TCP 연결 기반으로한다. 어떤 특정 연결 대에서 BEGIN TRANSACTION문, COMMIT문 사이의 모든 것은 같은 트랜잭션에 속하는 것으로 여겨진다.(이상적인 방법은 아니다. 커밋요청을 보냈지만 서버가 커밋여부를 확인해주기전에 연결이 끊긴다면 클라이언트는 알 방법이 없다.)  
반면 비관계형 데이터베이스는 이런 식으로 연산을 묶는 방법이 없는 경우가 많다.

### 다중 객체 트랜잭션의 필요성

단일 객체 트랜잭션 만으로 충분한 사용 사례가 있지만 많은 다른 경우에는 다중 객체 쓰기 작업 트랜잭션이 필요하다.

- 서로 참조하는 여러 레코드를 삽입할 때 참조 키는 항상 올바르고 최신 정보를 반영해야 한다. 다 중 객체 트랜잭션은 참조가 유효한 상태로 유지되도록 보장해준다.
- 비정규화된 여러 테이블의 데이터들을 한 번에 갱신해야 할 때(질의 속도 문제로 인하여 읽지 않은 이메일 갯수를 별도에 필드에 저장했을 때)
- 보조 색인이 있는 경우 값이 변경될 때 색인도 함께 갱신되어야 한다.

트랜잭션이 없더라도 이런 애플리케이션들을 구현할 수 있지만 원자성이 없으면 오류처리가 훨씬 더 복잡해지고, 격리성이 없으면 동시성 문제가 생길 수 있다.

### 오류와 어보트 처리

트랜잭션의 핵심 기능은 오류가 생기면 어보트되고 안전하게 재시도할 수 있다는 것이다.
어보트된 트랜잭션을 재시도하는 것은 간단하고 효과적인 오류 처리 메커니즘이니만 완벽하지 않다.

- 트랜잭션이 실제론 커밋되었지만 네트워크 문제로 클라이언트는 실패했다고 생각하여 중복 처리가 될 수 있다. 애플리케이션에 추가적인 중복 제거 메커니즘이 없다면!
- 오류가 과부하 때문이라면 트랜잭션 재시도는 문제를 악화시킬 수 있다. 해결하려면 재시도 횟수 제한, 지수적 백오프(1차시도 1초, 2차시도 2초, 3차시도4초 ..),과부화 관련오류 다른오류와 별도처리 등 방법을 사용할 수 있다.
- 일시적인 오류(데드락, 네트워크 오류, 시스템 장애)만 가치있고 영구적인 오류(제약 조건 위반)는 재시도해도 소용이 없다.
- 트랜잭션이 데이터베이스 외부에도 부수 효과가 있다면 트랜잭션 어보트 될 때도 부수 효과가 실행될 수 있다(ex.이메일 보내기)

## 완화된 격리 수준

트랜잭션이 직렬적으로 실행되는 직렬성 격리는 성능 비용이 크기 때문에 많은 데이터베이스는 그 비용을 지불하려고 하지 않는다. 따라서 어떤 동시성 이슈로부터는 보호해주지만 모든 이슈로부터는 보호해주지는 않는 완화된 격리 수준을 사용하는 시스템들이 흔하다.

- 직렬성격리 : 데이터 베이스가 여러 트랜잭션들이 직렬적으로 실행되는 것(즉 동시성 없이 한번에 트랜잭션 하나만 실행)과 동일한 결과가 나오도록 보장한다는 것을 의미.

### 1. 커밋 후 읽기(read committed)

가장 기본적인 트랜잭션 격리 수준으로 다음 두 가지를 보장해준다.

데이터베이스에서 읽을 때 커밋된 데이터만 본다.(더티 읽기가 없음)
데이터베이스에 쓸 때 커밋된 데이터만 덮어쓰게 된다.(더티 쓰기가 없음)

- **더티 읽기 방지**
  다른 트랜잭션에서 아직 커밋되지 않은 데이터를 보는 경우를 더티 읽기라고 부른다.
  커밋 후 읽기 격리 수준에서는 더티 읽기를 막아야 한다. 트랜잭션이 쓴 내용은 커밋된 후에야 다른 트랜잭션에게 보여야 한다.
  더티 읽기를 막는게 유용한 이유는 다음과 같다.

  - 트랜잭션이 여러 객체를 갱신하는데 더티 읽기가 생기면 일부는 갱신된 값을, 일부는 갱신되지 않은 값을 볼 수 있게 된다.
  - 트랜잭션이 어보트되면 롤백해야 하는데 더티 읽기가 생기면 실제로 커밋되지 않은 롤백된 데이터를 볼 수 있게 된다.

- **더티 쓰기 방지**
  아직 커밋되지 않은 트랜잭션에서 쓴 데이터를 새로운 트랜잭션이 덮어 쓰는 경우를 더티 쓰기라고 한다.
  커밋 후 읽기 격리 수준에서는 더티 쓰기를 막아야 한다.
  보통 먼저 쓴 트랜잭션이 커밋되거나 어보트될 때까지 두번째 쓰기를 지연시킨다.

  - 다른 트랙잭션에서 충돌하는 쓰기를 실행할 때 더티쓰기가 있으면 내용이 섞일 수 있다.

- **커밋 후 읽기 구현**
  더티 쓰기 방지:  
  가장 흔한 방법으로 로우 수준 잠금을 사용해 더티쓰기를 방지한다.  
  트랜잭션에서 특정 객체를 변경하고 싶다면 잠금을 획득해야 하고 트랜잭션이 커밋되거나 어보트될 때까지 잠금을 보유하고 있어야 한다. 오직 한 트랜잭션만 어떤 주어진 객체에 대해 잠금을 보유할 수 있다.
  더티 읽기 방지:  
  더티 읽기의 경우는 잠금을 사용하면 읽기만 실행하는 여러 트랜잭션들이 오랫동안 실행되는 쓰기 트랜잭션 하나가 완료될 때까지 기다려야 할 수 있기때문에 응답시간에 해를 끼친다.
  그렇기 때문에 데이터베이스는 쓰여진 모든 객체에 대해 과거에 커밋된 값과 현재 쓰기 잠금을 가진 트랜잭션에서 쓴 새로운 값을 모두 기억한다.
  한 객체에 쓰기 잠금을 가진 트랜잭션이 실행중인 동안 그 객체를 읽는 다른 트랜잭션은 해당 객체가 커밋하기 전까지는 과거에 커밋된 값을 읽게 된다.

  ### 2. 스냅숏 격리

  - 비반복 읽기(nonrepeatable read)
    은행 계좌 A, B에 각각 500달러씩 있고 A계좌에서 B계좌로 100달러를 전송하는 트랜잭션을 실행할 때, 트랜잭션이 처리되고 있는 순간에 계좌 잔고를 보면 A계좌는 400달러, B계좌는 500달로 나와 총 900달러가 있는 것처럼 보일 수도 있다. 이런 현상을 비반복 읽기(nonrepeatable read) 혹은 읽기 스큐(read skew)라고 하며 커밋 후 읽기 에서는 이런 현상을 막을 수 없다.
    시간이 지나 트랜잭션이 커밋되면 이런 현상은 사라지지만 이런 일시적인 비일관성도 감내할 수 없는 경우가 있다.(ex. 백업, 분석질의, 무결성 확인)

  - 스냅숏 격리
    스냅숏 격리는 위와 같은 문제를 해결할 수 있는 가장 흔한 해결책이다. 각 트랜잭션은 데이터베이스의 일관된 스냅숏으로부터 읽는다(특정 시점에 고정된 DB). 즉 트랜잭션은 시작할 때 데이터베이스에 커밋된 상태였던 모든 데이터를 본다. 데이터가 나중에 다른 트랜잭션에 의해 바뀌더라도 각 트랜잭션은 특정한 시점의 과거 데이터를 볼 뿐이다.
    스냅숏 격리는 PostgreSQL, InnoDB 저장소 엔진을 쓰는 MySQL, Oracle 등에서 지원한다.

  - 스냅숏 격리 구현
    스냅숏 격리에서는 더티쓰기를 방지하기 위해서는 쓰기 잠금을 사용한다. 그러나 읽을 때는 아무 잠금도 필요 없다. 성능관점에서 스냅숏격리의 핵심 원리는 읽는 쪽에서 쓰는 쪽을 결코 차단하지 않고 쓰는 쪽에서 읽는 쪽을 결코 차단하지 않는다는 것이다.
    스냅숏 격리를 구현하기 위해서는 객체마다 커밋된 버전 여러 개를 유지할 수 있어야 한다. 진행중인 여러 트랜잭션에서 서로 다른 시점의 데이터 베이스 상태를 봐야 할 수도 있기 때문이다.
    데이터베이스가 객체의 여러 버전을 함께 유지하는 기법을 다중 버전 동시성 제어(multi-version concurreny control, MVCC)라고 한다.
    스냅숏 격리를 지원하는 저장소 엔진은 보통 커밋 후 읽기 격리를 위해서도 MVCC를 사용한다. 커밋된 버전과 아직 커밋되지 않은 버전 2가지로 커밋 후 읽기 격리를 구현할 수 있다.
    스냅숏 격리 구현을 위해서는 트랜잭션 별로 계속 증가하는 고유한 트랜잭션 ID를 할당받는다. 트랜잭션이 데이터를 쓸 때 마다 해당 트랜잭션 ID와 버전별 객체가 기록되어 트랜잭션에 따라 특정 버전의 객체들을 읽을 수 있도록 한다. 테이블의 각 로우에는 그 로우를 테이블에 삽입한 트랜잭션의 ID를 갖는 `created_by`필드가 있다 또한 `deleted_by`필드도 있다. 트랜잭션이 로우를 삭제하면 실제 DB에서는 지우지 않고 deleted_by필드를 삭제요청 트랜잭션의 ID로 설정한다. 나중에 아무 트랜잭션도 삭제된 데이터에 접근하지 않는게 확실해지면 DB내의 가비지 컬렉션 프로세스가 지워졌다고 표시된 로우들을 지운다. 즉 데이터 갱신은 내부에서 삭제와 생성으로 변환된다 위의 계좌문제에서 계좌테이블에 있는 계좌A의 경우 두개의 로우를 가지게 된다. 트랜잭션이 삭제한 것으로 표시된 잔고 500달러 로우와 해당 트랜잭션이 생성한 잔고 400달러의 로우이다.
    각 트랜잭션이 시작되는 시점에 실행중인 트랜잭션들이 쓴 데이터와, 어보트 된 트랜잭션이 쓴 데이터, 트랜잭션 ID가 더 큰 트랜잭션이 쓴 데이터들은 후에 커밋여부와 관련없이 모두 무시된다.

    스냅숏격리는 유용한 격리 수준이며 특히 읽기 전용 트랜잭션에서 유용하다. 오라클에서는 직렬성PostgreSQL, MySQL에서는 반복 읽기(repeatable read)라고 표횬한다.

    ### 3. 갱신 손실 방지

    커밋 후 읽기와 스냅숏 격리는 주로 동시에 실행되는 쓰기 작업에서 읽기 전용 트랜잭션이 무엇을 볼 수 있는지에 대한 보장과 관련된 것이다.

    동시 쓰기를 실행할 때 발생할 수 있는 문제는 무엇이 있을까. 더티쓰기뿐만 아니라 동시에 실행되는 쓰기 트랜잭션 사이에 발생할 수 있는 충돌 상황들이 존재하며 가장 유명한 것이 갱신 손실(lost update) 문제이다.

    갱신 손실 문제는 애플리케이션이 데이터베이스에서 값을 읽고 변경한 후 변경된 값을 다시 쓸때 발생할 수 있다.(read-modify-write 주기). 두 트랜잭션이 동시에 해당 작업은 수행하는 경우 두번째 쓰기 작업이 첫 번째 견경을 포함하지 않으므로 발생할 수 있다.
    즉 두 클라이언트가 동시에 read-modify-write 주기를 실행할 때 한 트랜잭션이 다른 트랜잭션의 변경을 포함하지 않은 채로 다른 트랜잭션이 쓴 내용을 덮어써서 데이터가 손실되는 문제이다.

    - 카운터증가, 계좌잔고 갱신(현재 값 읽고 새 값 계산하고 갱신된 값 다시 써야한다.)
    - json문서내에 있는 리스트에 엘리먼트 추가 등 복잡한 값을 지역적 변경
    - 사용자 편집 내용 저장시 전체 내용 보내서 덮어쓰는 로직으로 구현된 위키에서 두명의 사용자 동시편집

    이처럼 갱신 손실 문제는 흔한 문제이기 때문에 다양한 해결책이 개발되었다.

    1. 원자적 쓰기 연산
       여러 데이터베이스에서 원자적 쓰기 연산을 제공하기 때문에 애플리케이션에서 read-modify-write 주기를 구현할 필요를 없애 준다.
       UPDATE counters SET value = value + 1 WHERE key = 'foo' 이 쿼리는 대부분의 관계형 데이터베이스에서 동시성 안전(concurrency-safe)하다.
       이 방법에서는 보통 객체를 읽을 때 그 객체에 독점적인 잠금을 흭득해서 구현한다. 그래서 갱신이 적용될 때까지 다른 트랜잭션에서 그 객체를 읽지 못하게 한다.
    2. 명시적인 잠금
       데이터베이스에서 원자적 쓰기 연산을 제공하지 않는다면 애플리케이션에서 객체를 명시적으로 잠그는 방식으로 해결할 수 있다. 한 트랜잭션의 read-modify-write의 주기가 완료될 때 까지 다른 트랜잭션이 동시에 같은 객체를 읽을 수 없고 기다려야 한다. 수동잠금이 필요하다.(SELETE FOR UPDATE)
       애플리케이션 로직에 대해 신중하게 생각해야 한다. 어딘가 로직의 실수로 경쟁조건 유발하기 쉽다.
    3. 갱신 손실 자동 감지
       병렬 실행을 허용하도록 하고 트랜잭션 관리자가 갱신 손실을 발견시 트랜잭션을 어보트 시키고 read-modify-write 주기를 재시도 하도록 강제하는 방법이 있다.
       애플리케이션 코드에서 어떤 특별한 데이터 베이스 기능도 쓸 필요가 없게 도와주므로 매우 좋은 기능이다. 명시적인 잠금을 실수로 빼먹었을 때 자동으로 갱신 손실을 감지하여 트랜잭션을 어보트 시킬 수 있기 때문에 오류를 덜 방생시킨다.
       이 방법의 이점은 데이터 베이스가 이 확인을 스냅숏 격리와 결합해 효울적으로 수행할 수 있다는 것이다.
       실제로 PostgreSQL,오라클, SQL 서버의 스냅숏 격리는 갱신손실이 발생하면 자동으로 발견해서 해당 트랜잭션을 어보트 시키는 이 기능을 제공하지만 InnoDB 기반의 MySQL은 이 기능을 제공하지 않는다.

    ..

    ### 또 다른 문제들

    - 쓰기쓰큐
      트랜잭션이 무언가를 읽고 읽은 값을 기반으로 어떤 결정을하고 그 결정을 데이터베이스에 쓴다. 그러나 쓰ㄹ기를 실행하는 시점에는 결정의 전제가 더이상 참이 아니다. 직렬성 격리만 이런 현상을 막을 수 있다.

    - 팬텀 읽기
      트랜잭션이 어떤 검색 조건에 부합하는 객체를 읽는다. 다른 클라이언트가 그검색 결과에 영향을 주는 쓰기를 실행한다. 스냅숏 격리는 간단한 팬텀 읽기는 막아주지만 쓰기 스큐 맥락에서 발생하는 팬텀은 색인 범위 잠금처럼 특별한 처리가 필요하다.
      -->

    ## 직렬성 격리

    완화된 격리 수준은 모든 문제를 막아주지 못한다. 직렬성 격리만 모든 문제들을 보호해준다.

    ### 1. 트랜잭션 순서대로 실행

    트랜잭션의 실행 시간이 아주 짧고 트랜잭션 처리량이 단일 CPU 코어에서 처리할 수 있을정도로 트랜잭션 처리량이 낮다면 아주 간단하고 효과적이다.

    ### 2. 2단계 잠금

    수십년동안 직렬성을 구현하는 표준적인 방법이었지만 성능 특성 때문에 사용을 피하는 애플리케이션이 많다.

    ### 3. 직렬성 스냅숏 격리(SSL)

    스냅숏 격리에 직렬성의 요소를 더한 것으로, 직렬성 스냅숏 격리는 완전한 직렬성을 제공하지만 스냅숏 격리에 비해 약간의 성능 손해만 존재한다
    직렬성 스냅숏 격리 앞에서 언급한 결점 중 대부분을 피하는 상당히 새로운 알고리즘이다. 2단계 잠금은 비관적 동시성 제어 메커니즘이라면 직렬성 스냅숏 격리는 낙관적 동시성 제어 기법이다. 낙관적인 방법을 사용해서 트랜잭션이 차단되지 않고 진행 할 수 있게한다. 트랜잭션이 커밋을 원할 때 트랜잭션을 확인해서 실행이 직렬적이지 않으면 어보트 시킨다.
    위험한 상황이 발생할 수 있을 때에도 일단 진행한다. 마지막에 커밋할 때 격리 위반을 확인하고 어보트한다. 쓰기 스큐처럼 질의 결과(전제 조건)와 쓰기 작업 사이 인과적 의존성이 있을 때, 전제 조건이 최신 결과가 아니면, 이를 감지해서 트랜잭션을 어보트시켜서 직렬성 격리를 제공한다.
    어보트 비율은 SSI의 전체적인 성능에 큰 영향을 미친다. 이를테면 오랜 시간 동안 데이터를 읽고 쓰는 트랜잭션은 충돌이 나고 어보트되기 쉬워서, SSI는 읽기 쓰기 트랜잭션이 상당히 짧기를 요구한다 오래 실행되는 읽기 전용 트랜잭션은 괜찮다. 2PL이나 싱글쓰레드 실행보다는 덜 민감하다.
