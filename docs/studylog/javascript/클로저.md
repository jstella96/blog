---
order: 7
icon: creative
title: 클로저
category:
  - JavaScript
editLink: false
---

::: tip GOAL
Q. 클로저란 무엇이고 어떻게 발생하게 되는가?  
:::
해당페이지는 2022년 3월 노션에서 마이그레이션 되었습니다.

## 클로저(closure)

==**(핵심) 함수 종료 후에도 사라지지 않는 지역변수를 만들 수 있다.**==

클로저를 설명하자면

- 내부함수와 LexicalEnvironment의 조합  
  ex. 어떤 실행 컨텍스트A에서 함수 B를 선언, 이때에 A의 LexicalEnvironment 와 내부 함수 B의 조합

- 함수가 생성될 때면 매번 같이 발생한다. 함수의 생성과 함께 무조건 생기는 당연한 개념이다. 그러나 모든 보편적 상황에 모두 적용하진 않는다

- 흔히 ..using closure, ..with closure 등 클로저 환경에서만 발생하는 무언가 특별한 현상을 표현하기 위해서 이 '클로저' 라는 현상에 주목한다.

A의 LexicalEnvironment와 내부함수 B의 조합에서 나타나는 특별한 현상 이라고 정리할 수 있다.

조금 더 자세히 살펴보면

```
A:
LexicalEnviroment
  enviromentRecord // 이부분 - 선언
  outerEnvironmentReference

B:
LexicalEnviroment
  enviromentRecord
  outerEnvironmentReference // 이부분 - 참조
```

B의 outerEnvironmentReference 와 A의 enviromentRecord 둘 사이의 조합 =>
**컨텍스트 A에서 선언한변수를 내부함수 B에서 참조할 경우에 발생하는 특별한 현상**

## 특별한 현상

```js
var outer = function () {
  var a = 1;  // outer 컨텍스트에서 선언
  var inner = function () {
    console.log(++a); // 내부함수 inner 에서 참조
  };
  inner();
};
outer();
```

위는 특별할께 없다.
`전역 컨텍스트 -> outer 컨텍스트-> inner컨텍스트` 순서로 진행된다.  
그러나 아래 코드를 보자.

```js
var outer = function () {
  var a = 1;
  var inner = function () {
    return ++a; // outer 컨텍스트에서 선언한 변수를 내부함수 inner 에서 참조(o)
  };
  return inner();
};
var outer2 = outer();
console.log(outer2()); //2
console.log(outer2()); //3
```

### 실행흐름

```
전역공간 : enviromentRecord { outer: f, outer2: undefined }
//outer 호출
전역공간 : { enviromentRecord { outer :f, outer2 :undefined }
outer F : { enviromentRecord : { a:1, inner: f }, outerEnvironment : { outer: f } }
//outer 호출 끝
//inner가 참조하고 있기 때문에 a의 참조카운트가 0이 아닌상태이다.
전역 : enviromentRecord {outer :f, outer 2 :inner } 

outer F : { enviromentRecord : { a:1 } //그렇기에 a 가 살아 남는다.
//outer2 호출 - 2호출
inner F : { enviromentRecord:{} , outer : {  a:2 } } 
outer F : {  enviromentRecord : { a:2 } } 
전역공간 : { enviromentRecord {outer :f, outer 2 :inner } 

-> outer2 가 inner 함수를 참조하고 있는데 inner함수는 a변수를 참조하니까 a가 사라지지않는 변수가 되었다. a를 끊으려면 outer2 다른 값을 대입해서 각 참조를 끊어내야 한다.
-> inner 참조카운트 0 , a 참조카운트 0이 되면 둘 다 GC대상이된다.
```


## 결론

클로저란 컨텍스트 A에서 선언한 변수 a를 참조 하는 내부함수 B를 A의 외부로 전달할 경우, A가 종료된 이후에도 a가 사라지지 않는 현상을 말한다.클로저를 사용하면 함수 종료 후에도 사라지지 않는 지역변수를 만들 수 있다.


**또 다른 예제**
```javascript
function user(_name) {
  // 객체를 반환하는 함수
  var _logged = true;
  return {
    get name() {
      //name 출력하라고 하면 getter 호출
      return _name; //매개변수 넘겨받은 값을 가지는 user 함수내에서 선언한 변수,
      //원래라면 user 함수 실행컨텍스트 종료시 사라져야함
      // 그러나 참조카운트가 0 이 아니니까 살려진다. (함수는 죽었음에도 변수는 살아있다)
    },
    set name(v) {
      _name = v;
    },
    login() {
      _logged = true;
    },
    logout() {
      logged = false;
    },
    get statue() {
      return _logged ? "login" : "logout"; // 캡슐화
    },
  };
}
var roy = user("재남");

cosole.log(roy.name); //재남
roy.name = "제이";
cosole.log(roy.name); //제이
roy._name = "로이"; // loy객체에 _name 프로퍼티 없음 영향x
cosole.log(roy.name); //제이
cosole.log(roy.status); //login;
roy.logout();
cosole.log(roy.status); //logout;
roy.statue = true; // (roy.status getter는 있으나 setter 무시 - 캡슐화에 의해서
cosole.log(roy.status); //logout;
```

1. 함수 종료 후에도 사라지지 않고 값을 유지하는 변수
2. 외부로부터 내부 변수 보호(캡슐화) //위 변수들 보호할수있는 방법이 있다. => 캡슐화라고 한다.


## 추가 공부

클로저에 의한 메모리 누수 관리 방법  
클로저 활용한 다양한 프로그래밍 기법

## Reference

[코어 자바스크립트(인프런)](https://www.inflearn.com/course/%ED%95%B5%EC%8B%AC%EA%B0%9C%EB%85%90-javascript-flow/dashboard)
