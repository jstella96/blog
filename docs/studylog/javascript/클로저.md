---
index: 7
icon: creative
title: 클로저
category:
  - JavaScript
editLink: false
---

::: tip GOAL
Q. 클로저란 무엇이고 어떻게 발생하게 되는가?  
:::
해당페이지는 2022년 3월 노션에서 마이그레이션 되었습니다.  

## 클로저(closure)

==**(핵심) 함수 종료 후에도 사라지지 않는 지역변수를 만들 수 있다.**==

클로저를 설명하자면

- 내부함수와 LexicalEnvironment의 조합
  ex. 어떤 실행 컨텍스트A에서 함수 B를 선언, 이때에 A의 LexicalEnvironment 와 내부 함수 B의 조합

- 함수가 생성될 때면 매번 같이 발생한다. 함수의 생성과 함께 무조건 생기는 당연한 개념이다. 그러나 모든 보편적 상황에 모두 적용하진 않는다

- 흔히 ..using closure, ..with closure 등 클로저 환경에서만 발생하는 무언가 특별한 현상을 표현하기 위해서 이 '클로저' 라는 현상에 주목한다.

A의 LexicalEnvironment와 내부함수 B의 조합에서 나타나는 특별한 현상 이라고 정리할 수 있다.

조금 더 자세히 살펴보면

```
B:
LexicalEnviroment
  enviromentRecord
  outerEnvironmentReference // 이부분

A:
LexicalEnviroment
  enviromentRecord // 이부분
  outerEnvironmentReference
```

B의 outerEnvironmentReference 와 A의 enviromentRecord 둘 사이의 조합

**즉 컨텍스트 A에서 선언한변수를 내부함수 B에서 참조할 경우에 발생하는 특별한 현상**

## 특별한 현상

```js
var outer = function () {
  var a = 1;
  var inner = function () {
    console.log(++a); // outer 컨텍스트에서 선언한 변수를 내부함수 inner 에서 참조(o)
  };
  inner();
};
outer();
```

위는 특별할께 없다.
`전역 컨텍스트 -> outer 컨텍스트{ enviromentRecord: {a:1->2 , inner}} -> inner` 순서로 진행된다.  
그러나 아래 코드를 보자.

```js
var outer = function () {
  var a = 1;
  var inner = function () {
    return ++a; // outer 컨텍스트에서 선언한 변수를 내부함수 inner 에서 참조(o)
  };
  return inner();
};
var outer2 = outer();
console.log(outer2()); //2
console.log(outer2()); //3
```

### 실행흐름

```
전역 : enviro {outer :f, outer 2 :undefined } //아직 outer 호출전
// outer 호출
outer : { envir .. : {a:1, inner:f }, outer.. : {outer:f}}
전역 : enviro {outer :f, outer 2 :undefined }
//outer 호출 끝
outer : { envir .. : {a:1} //a 가 살아 남는다.
전역 : enviro {outer :f, outer 2 :inner } //inner가 참조하고 있기 때문에 참조카운트가 0이 아닌상태이다.
//outer2 호출 - 2호출
inner {en.. :{] , outer : {a:1 ->2}}
outer : { envir .. : {a:1 } // a가 살아 남는다.
전역 : enviro {outer :f, outer 2 :inner } //inner가 참조하고 있기 때문에 참조카운트가 0이 아닌상태이다.

-> outer 2 가 inner 물고있는데 inner 다 a 참조하니까 끊으려면 outer 2다른거 대입
-> inner 참조카운트 0 -> a 참조카운트 0 둘다 GC대상이됨
```

## 결론

컨텍스트 A에서 선언한 변수 a를 참조 하는 내부함수 B를 A의 외부로 전달할 경우, A가 종료된 이후에도 a가 사라지지 않는 현상.  
클로저를 사용하면 함수 종료 후에도 사라지지 않는 지역변수를 만들 수 있다.

:::warning 예제

```javascript
function user(_name) {
  // 객체를 반환하는 함수
  var _logged = true;
  return {
    get name() {
      //name 출력하라고 하면 getter 호출
      return _name; //매개변수 넘겨받은 값을 가지는 user 함수내에서 선언한 변수,
      //원래라면 user 함수 실행컨텍스트 종료시 사라져야함
      // 그러나 참조카운트가 0 이 아니니까 살려진다. (함수는 죽었음에도 변수는 살아있다)
    },
    set name(v) {
      _name = v;
    },
    login() {
      _logged = true;
    },
    logout() {
      logged = false;
    },
    get statue() {
      return _logged ? "login" : "logout"; // 캡슐화
    },
  };
}
var roy = user("재남");

cosole.log(roy.name); //재남
roy.name = "제이";
cosole.log(roy.name); //제이
roy._name = "로이"; // loy객체에 _name 프로퍼티 없음 영향x
cosole.log(roy.name); //제이
cosole.log(roy.status); //login;
roy.logout();
cosole.log(roy.status); //logout;
roy.statue = true; // (roy.status getter는 있으나 setter 무시 - 캡슐화에 의해서
cosole.log(roy.status); //logout;
```

1. 함수 종료 후에도 사라지지 않고 값을 유지하는 변수
2. 외부로부터 내부 변수 보호(캡슐화) //위 변수들 보호할수있는 방법이 있다. => 캡슐화라고 한다.
   :::

## 추가 공부

클로저에 의한 메모리 누수 관리 방법  
클로저 활용한 다양한 프로그래밍 기법
