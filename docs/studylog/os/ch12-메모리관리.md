---
index: 12
icon: creative
title: 메인메모리
category:
  - OS
tag:
  - 운영체제
editLink: false
---

::: tip GOAL
Q. 메모리 할당방법은?  
Q. 연속 메모리 할당 방법이란?  
Q. 메모리 할당방법은?  
Q. 분산 메모리 할당 방법인 페이징 방법과 세그먼테이션을 설명하시오.  
:::
해당페이지는 2022년 3월 노션에서 마이그레이션 되었습니다.

## 메인 메모리

- CPU가 직접 접근할 수 있는 메모리
- 프로그램이 실행될 때 프로그램이 복사되어 메모리에 적재되어 프로세스가 됨
- CPU는 PC가 지시하는 대로 연산을 수행한 후 메인 메모리에 데이터를 저장하거나
  필요한 데이터를 요구

## 기본적인 메모리 구성

- 각 프로세스에는 개별적인 메모리 공간이 존재한다. 특정 프로세스만 접근할 수 있는 합법적인(legal) 메모리 주소 영역을 설정하여 특정 프로세스가 해당 영역만을 접근하도록 하는 기능이 필요하다.(보안적 이유)
- 기준(base)레지스터 : 가장 작은 합법적인 물리 메모리 주소
- 상한(limit)레지스터 : 주어진 영역의 크기
- 프로세스 메모리 영역 : base ~ base + limit
- 기준레지스터와 상한레지스터 하드웨어를 통해서 유저 프로그램이 운영체제나 다른 유저 코드 or 데이터 구조의 임의 수정을 방지한다.

## 주소할당(Address Binding)

- 프로그램이 실행되려면, 메모리로 적재한 뒤 프로세스 컨택스트 내에 배치해야 한다.
- 유저 프로그램은 실행되기 전 여러 단계를 거친다.
- 주소는 이 단계에서 여러 다른 방식으로 표시될 수 있다.
  - 원시 프로그램에서의 주소는 일반적으로는 기호(symbolic)형태로 표현
  - 컴파일러는 이런 기호 주소를 재배치 가능한 주소에 바인딩
  - Linker나 Loader는 재배치 가능한 주소를 절대 주소로 바인딩

## 주소할당의 구분

메모리 주소 공간에서 명령어와 데이터의 바인딩은 그 바인딩이
이루어지는 시점에 따라 구분

- 컴파일 시간 바인딩: 컴파일 시간에 프로세스가 메모리에 상주할 위치를 미리 알
  수 있다면 컴파일러는 절대코드를 생성할 수 있음(논리주소 = 물리주소)
- 적재 시간 바인딩: 프로세스가 메모리에 상주할 컴파일 시간을 알 수 없는 경우
  컴파일러는 재배치 가능한 코드를 생성해야 함(논리주소 = 물리주소)
- **실행 시간 바인딩**: 프로세스가 실행 중에 한 메모리 세그먼트에서 다른 메모리
  세그먼트로 이동할 수 있는 경우 바인딩은 실행 시간까지
  연기되어야 함(논리주소 ≠ 물리주소)

- 가상 주소에서 실제 주소로의 **실행 시간 맵핑**은 MMU(메모리 관리 장치,
  Memory Management Unit)라고 하는 하드웨어 장치에 의해 수행
  - 주소가 메모리로 전송될 때, 유저 프로세스에 의해 생성된 모든 주소에 재배치
    레지스터(기본 레지스터)의 값이 추가됨
  - 유저 프로그램은 실제 물리적 주소에 절대 접근할 수 없음
  - 논리주소(Logical Address) => MMU( + 재배치 레지스터) => 물리주소(physical Address)

## 메모리 보호

- 재배치 레지스터: 가장 작은 물리 주소의 값을 저장
- 상한 레지스터: 논리 주소의 범위값 저장
- 각 논리 주소는 상한 레지스터에 의해 지정된 범위 내에 존재해야 함
- MMU는 동적으로 논리 주소에 재배치 레지스터 값을 더하여 주소 변환

---

## 메모리 할당

- 다중 파티션 방식(고정 분할 방법)

  - **메모리를 여러개의 고정된 크기로 분할하고, 분할된 각 메모리는 프로세스(작업) 하나를 실행 할 수 있다**
  - 내부 단편화, 외부 단편화가 발생한다
  - 각 파티션은 정확히 하나의 프로세스를 포함할 수 있음
  - 멀티프로그래밍의 정도는 파티션 수에 의해 결정됨
  - 파티션이 비어 있으면 입력 큐에서 프로세스가 선택되어 비어있는 파티션에 로드됨
  - 프로세스가 종료되면 파티션을 다른 프로세스에서 사용할 수 있게 됨

![고정분할](./img/3-%EA%B3%A0%EC%A0%95%EB%B6%84%ED%95%A0-%EB%B0%A9%EC%8B%9D.png)
- 가변 분할 방식

  - 고정된 경계를 없애고 각 프로세스가 필요한 만큼 메모리를 할당한다. 사용 가능 공간을 어느 작업에 할당할지 결정하는 방법 아래와 같다
  - OS는 **사용 가능한 메모리 부분과 사용 중인 메모리 부분을 나타내는 테이블을 유지**
  - 모든 메모리는 유저 프로세스에 사용 가능. 사용 가능한 메모리의 큰 블록을
    hole이라고 지칭
  - 사용 가능 공간을 어느 작업에 할당할지 결정하는 방법 아래와 같다

    - 최초 적합 :
      - 첫 번째 사용 가능한 가용 공간 선택
      - 집합의 시작에서부터 검색하거나, 지난번 검색이 끝났던 곳에서 시작
      - 충분히 큰 가용 공간을 찾았을 때 검색 종료
    - 최적 적합 :
      - 사용 가능한 공간들 중에서 가장 작은 공간 선택
      - 아주 작은 가용 공간을 만들어 냄
      - 리스트가 크기 순으로 되어 있지 않다면 전체 리스트를 검색해야 함
    - 최악 적합 :

      - 가장 큰 가용 공간 선택
      - 할당 이후 남는 자유공간이 충분히 커서 다른 프로세스들이 사용해야 함
      - 자유공간이 크기 순으로 정렬되어 있지 않으면 전 리스트 다 검색해야 함

    - 최초 적합, 최적 적합 모두 외부 단편화가 발생함  

![가번분할](./img/3-%EA%B0%80%EB%B3%80%EB%B6%84%ED%95%A0-%EB%B0%A9%EC%8B%9D.png)
## 단편화

- 내부 단편화
  - 프로세스에 할당된 메모리가 요청된 메모리 보다 커서 그사이 남는 부분
- 외부 단편화
  - 요청을 충족하기에 충분한 총 메모리 공간이 있지만, 사용할 수 있는 공간 연속적이지 않아서 메모리를 사용할 수 없는 상황
  - 스토리지가 여러 개의 hole들로 분할됨
  - 총 메모리 저장 용량과 평균 프로세스 크기에 따라 외부 단편화는
    사소하거나 / 중요한 문제일 수 있음
  - 해결방법 → 압축, 페이징 (없애는 방법)
    - 페이징: 물리 메모리를 고정 크기 블록으로 나누고
      블록 크기에 따른 정수배로 메모리 할당
    - 압축: 사용 가능한 모든 메모리를 하나의 큰 블록으로 만들도록 메모리를
      모으는 것
      - 재배치가 동적이고 실행시간에 수행되는 경우만 가능
      - 압축이 가능할 경우 비용 결정이 필요
      - 모든 프로세스를 메모리의 한쪽 끝으로 이동



## 페이징

프로세스의 물리 주소 공간이 연속적이지 않도록 하는 메모리 관리체계이다.
외부 단편화 방지, 내부단편화는 존재

- 페이징기본 방법
  - 물리 메모리를 프레임이라고 하는 고정된 크기의 블록으로 나눔
  - 논리 메모리를 페이지라고 하는 동일한 크기의 블록으로 나눔
  - CPU에 의해 생성된 모든 주소는 페이지 번호(p), 페이지 오프셋(d) 두 부분으로 나뉨
    - 페이지 번호 : 페이지 테이블에 대한 인덱스로 사용
    - 페이지 테이블: 물리 메모리에 있는 각 프레임의 기본주소를 포함. 프레임의 기본주소가 페이지 오프셋과 결합되어 물리 메모리 주소 정의
  - TLB : 히트하면 물리주소로 매핑 없으면 페이지 테이블가서 찾음
  - 보호
  - 공유페이지

