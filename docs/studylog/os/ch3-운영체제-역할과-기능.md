---
order: 3
icon: creative
title: 운영체제 역할과 기능
category:
  - OS
tag:
  - 운영체제
editLink: false
---

:::tip GOAL
Q. 운영체제의 역할은 무엇인가요?  
Q. 운영체제의 자원관리 기능을 설명하세요.  
Q.인터럽트가 무엇인가요? 발생에 따른 컴퓨터 수행 흐름은?
:::
해당페이지는 2022년 3월 노션에서 마이그레이션 되었습니다.  
밑에 있는 그림들은 개인적인 이해를 돕기 위해 그린 그림으로 실제 원리와 맞지 않을 수도 있습니다.

## 운영체제의 역할

- 자원 할당의 주체
  - 모든 자원를 관리
  - 응용 프로그램간의 하드웨어 사용을 제어, 조정하는 역할
  - 자원에 대한 충돌되는 요청 사이에서 효율적이고 공정하게 사용하도록 자원 분배
- 제어를 전담
  - 프로그램 실행을 제어, 오류 및 부적절한 사용 방지

여기서 자원이란 CPU(Central processing Unit), 메모리, 하드디스크 등 하드웨어 자원뿐 아니라 소프트웨어 자원까지를 통칭해서 부르는 말

## 운영체제의 자원관리 기능

- 어떤 프로그램에 CPU를 줄 것인가? **CPU스케줄링-프로세스 관리**
- 한정된 메모리를 어떻게 나누어 사용할 것인가? **메모리 관리**
- 디스크에 파일을 어떻게 보관할 것인가? **파일 관리**
- 각기 다른 입출력 장치와 컴퓨터 간에 어떻게 정보를 주고받을 것인가? **입출력장치 관리**

### 1. CPU 스케줄링

매 시점 어떤 프로세스에 CPU를 할당해 작업을 처리할 것인지 결정하는 일이 필요하다. 이러한 일을 CPU스케줄링 이라고 한다 CPU스케줄링 목표는 CPU를 효율적으로 사용하면서도 특정 프로세스가 불이익을 당하지 않도록 하는것이다. 대표적으로 선입선출(FIFS), 라운드 로빈(Round Robin), 우선순위(priority) 기법 등이 있다.

**선입선출**  
먼저 도착한 프로세스를 먼저 처리하는 스케줄링 기법이다. 시스템 입장에서 비효율적이다. 만약 긴 작업시간을 요구하는 프로세스가 앞에 있다면 후에 도착하는 프로세스들은 그 작업이 완료될 때 까지 오랜시간 기다려야 한다.

**라운드로빈**  
CPU를 할당받아 사용할 수 있는 시간이 일정하도록 고정된 시간으로 제한하는 스케줄링 기법이다. 긴 작업시간을 요구하는 프로세스가 CPU를 할당받고, 진행하던 작업이 끝나지 않았더라도 정해진 시간이 지나면 CPU를 내어놓고 대기열의 제일 뒤로 가야한다.

**우선순위**  
대기중인 프로세스들에게 우선순위를 부여하고 우선순위가 높은 프로세스에게 CPU를 먼저 할당하는 스케줄링 기법이다.
만약 특정 작업이 지나치게 오래 기다리게 되면 우선순위를 높여주는 등의 방안을 고려해야 한다.(기아상태를 방지하기 위한 에이징)

### 2. 메모리 관리

메모리란 CPU가 직접 접근할 수 있는 컴퓨터 내부의 기억장치이다. 프로그램이 CPU에서 실행되려면 해당 부분이 메모리에 올라가 있어야한는데 한정된 메모리 공간에 여러 프로그램을 수용하기 위해서 효율적인 관리 메커니즘이 필요하다.  
따라서 메모리 관리를 위해 운영체제는 메모리의 어떤 부분이 어떤 프로그램에 의해 사용되고 있는지를 파악하여 이를 유지 하게 되는데 이러한 정보는 **주소(address)** 를 통해 관리 된다.
물리적 메모리를 관리하는 방식에는 **고정분할(fixed partition) 방식**, **가변분할(variable partition) 방식**, **가상메모리(virtual memory) 방식** 등이 있다.

**1. 고정분할 방식**  
물리적 메모리를 몇 개의 분할로 미리 나누어 관리한다. 메모리에 동시 적재되는 최대 프로그램수가 분할 개수로 한정되며, 분할의 크기보다 큰 프로그램은 적재 불가능하다. 또한 분할이 고정적이기 때문에 분할의 크기보다 작은 프로그램이 적재되는 경우 해당 분할 내에 남는 영역이 발생한다. 이것을 **내부조각(internal fragmentation)** 이라고 하는데 이 내부조각은 사용될 수 없으므로 낭비되는 공간이다. 이 방식은 메모리의 효율적인 사용측면에서 바람직하지 못하다.

![고정분할](./img/3-%EA%B3%A0%EC%A0%95%EB%B6%84%ED%95%A0-%EB%B0%A9%EC%8B%9D.png)

**2.가번분할 방식**  
가변분할 방식은 매 시점 프로그램의 크기에 맞게 메모리를 분할해서 사용하는 방식을 말한다. 따라서 분할의 크기 때문에 큰 프로그램의 실행이 제한되는 문제는 발생하지 않는다 그러나 물리적 메모리 크기보다 큰 프로그램 실행은 여전히 불가능 하다. 가변분할 방식에서는 분할의 크기와 개수가 동적으로 변하므로 기술적 관리 기법이 필요하다. 가변분할에서는 내부조각이 발생하진 않지만 외부조각(external fragmentation)이 발생 할 수있다 외부조각이란 프로그램에 할당 되지는 않았지만 그 크기가 작아 프로그램을 올리지 못하는 메모리 영역을 말한다. 크기가 100인 프로그램 A가 실행되어 메모리에 100만큼의 영역을 할당 받았다. 그후 크기가 50인프로그램이 실행되어 A영역 바로 다음부터 메모리 공간 50을 할당받았다. A 프로그램이 끝난 후 크기가 90인 프로그램 C가 A가 차지 했던 영역에 적재되면 10만큼의 빈공간이 생기게된다. 이후 크기가 40인프로그램 D가 들어온다면 10의 공간은 D가 사용하기에 충분하지 못하기 때문에 빈공간 10을 사용하지 못한다 이와같은 크기 10의 낭비되는 공간을 외부조각이라한다. 외부조각 또한 낭비된 메모리 자원이다.

![가번분할](./img/3-%EA%B0%80%EB%B3%80%EB%B6%84%ED%95%A0-%EB%B0%A9%EC%8B%9D.png)

**3. 가상메모리 방식**  
가상 메모리 기법은 현대에서 가장 널리 사용되는 메모리 관리 기법이다. **이 기법은 물리적 메모리 보다 더 큰 프로그램이 실행 되는 것을 지원 한다.** 이때 실행 될 수 있는 프로그램의 크기는 가상메모리의 크기에 의해 결정된다.
모든 프로그램은 물리적 메모리와는 독립적로 0번지 부터 시작하는 자신만의 가상메모리 주소를 갖는다. 운영체제는 이 가상메모리 주소를 물리적 메모리 주소로 매핑하는 기술을 이용해 주소를 변환시킨 후 프로그램을 물리적 메모리에 올리게 된다.
가상메모리 기법에서는 물리적메모리의 크기와 상관없이 사용할 수 있는 메모리 크기가 충분히 크다고 가정하고 프로그램을 개발할 수 있다. **이것을 가능하게 하는 원리는 메모리가 1Gbyte고 프로그램이 2Gbyte라 하더라도 전체가 항상 동시에 사용되는 것은 아니기 때문이다.** 그러므로 현재 사용되고 있는 부분만 메모리에 올리고 나머지는 하드디스크와 같은 보조기억장치에 저장해두었다가 필요할 때 적재하는 방식을 취한다. 이때 사용되는 보조기억장치 영역을 스왑영역(swap area)이라고 부른다, 프로그램을 구성하는 가상메모리 주소공간은 페이지(page)라는 동일한 크기의 작은 단위로 나뉘어 물리적 메모리와 스왑영역에 일부분씩 저장된다. 이렇게 동일한 단위로 메모리를 나누는 기법을 페이징(pagging)기법이라고 한다.

### 3. 주변장치 및 입출력 장치

CPU는 인터럽트(interrupt)라는 메커니즘을 통해 관리가 이루어진다. 주변장치들은 CPU의 서비스가 필요한 경우 신호를 발생시켜 서비스를 요청 하는데 이때 발생하는 신호를 인터럽트 라고 한다. CPU는 평소에 CPU 스케줄링에 따라 자기에게 주어진 작업을 수행하다가 인터럽트가 발생하면 하던 일을 잠시 멈추고 인터럽트에 의한 요청 작업을 수행한다. 예를 들어 키보드에 의해 인터럽트가 발생하면 CPU는 하던 일을 멈추고 해당 입력 데이터를 해당 프로그램에 전달하는 절차를 수행한다. 인터럽트에 의한 작업을 처리한 후에 하던 일을 계속 수행한다. 이때 수행하던 작업으로 돌아오기 위해 직전의 작업상태를 저장해둔다. 인터럽트는 요청하는 장치와 발생상황에 따라 다양한 종류가 있기 때문에 인터럽트 종류마다 서로 다른 인터럽트 처리루틴을 가지고 있다. 인터럽트 처리루틴이란 인터럽트가 발생했을 때 해주어야 할 작업을 정의한 프로그램 코드를 말한다.

한편 주변 장치들은 각 장치 마다 그 장치에서 일어나는 업무를 관리하기 위한 일종의 작은 CPU를 가지고 있다.
이는 우리는 컨트롤러(controller, 제어기)라고 부른다 컨트롤러는 해당장치에 대한 업무를 처리하고 이를 메인 cpu에 인터럽트를 발생시켜 보고하는 역할을 한다.

:::info 인터럽트
CPU가 프로그램을 구동하고 있을 때 입출력 혹은 예외 상황이 발생해서 처리가 필요한 경우에 CPU에 신호를 보내는 것

[인터럽트 수행흐름]

1. 기존에 기동되고 있던 유저 프로세스에 인터럽트가 발생(인터럽트 신호 발생)
2. IRQ(Interrupt ReQuest)인터럽트 리퀘스트가 들어오면 CPU에게 signal을 보낸다.
3. signal이 transfer이 완료가 되면 interrupt가 걸린다.
4. CPU는 자신의 일(process)을 잠시 멈추고 PCB(Process Control Block)에 저장한다.
   (PCB- 인터럽트가 발생했을 때 그 프로그램의 어느 부분까지 수행했는지를 저장하기 위한 영역)
5. CPU는 interrupt service routine(interrupt handler)/인터럽트 처리루틴으로 가서 interrupt processing처리 한다.
6. CPU는 interrupt service routine에서 일을 처리가 종료되면, 원래 process 위치(주소)로 돌아가 원래 하던 일을 한다.

[예시]
대략적인 키보드 인터럽트 처리순서
키보드 입력 -> 키보드 컨트롤러가 인터럽트 발생 -> CPU현재 수행중이던 작업 저장 -> 인터럽트 요청처리위해 운영체제내에 키보드 인터럽트처리루틴 찾아감 -> 인터럽트처리루틴이 키보드로부터 입력받은 내용을 메모리 특정부분에 저장헤 해당프로그램에게 키보드 입력이 들어왔음을 알림-> 인터럽트 처리완료 -> 인터럽트 발생직전상태 복구

이와 같은 방식으로 주변장치들은 CPU 서비스 받을수있음
:::

:::info 컴퓨터 시스템 운영, 동작

- 메모리 관리루틴, CPU스케줄링, 인터럽트 처리루틴 등의 코드는 운영체제 커널내에 존재하는 코드이다.
- 메모리를 두고 경쟁하는 입출력 장치, CPU는 동시 실행 가능
- 하나 이상의 CPU, 장치 컨트롤러는 공유된 메모리에 대한 접근을 제공하는 공용 버스를 통해 연결됨
- 각 장치 컨트롤러는 특정 디바이스 유형을 담당. 로컬 버퍼 존재
- CPU는 메인 메모리 - 로컬 버퍼간 데이터 이동
- 입출력은 장치에서 컨트롤러의 로컬 버퍼로 전달
- 장치 컨트롤러는 인터럽트를 발생시켜 CPU에 작업 완료를 알림

:::
